//! Adapter between the blueprint-defined STWO objects and the official prover
//! interfaces.
#![allow(unexpected_cfgs)]
//!
//! The adapter owns references to the blueprint primitives (`AirDefinition`,
//! `ExecutionTrace`, and `StarkParameters`) while pre-computing fast lookup
//! tables for the execution trace segments. These descriptors are used by
//! subsequent trait implementations to bridge the lightweight blueprint models
//! with the official prover APIs.

use std::collections::HashMap;

use thiserror::Error;

use super::{
    air::AirDefinition,
    circuit::{ExecutionTrace, TraceSegment},
    params::StarkParameters,
};

/// Re-export key prover traits and types from the official STWO implementation
/// so that downstream modules can rely on them without repetitive imports.
pub use stwo::stwo_official::core::{ColumnVec, air::Component, pcs::TreeVec};

/// Re-export prover-side structures when the upstream dependency exposes them.
#[cfg(feature = "stwo/prover")]
pub use stwo::stwo_official::prover::{
    air::component_prover::ComponentProver, backend::cpu::CpuBackend,
    poly::circle::CircleEvaluation,
};

/// Errors that can be raised while validating execution trace descriptors.
#[derive(Debug, Error)]
pub enum AdapterError {
    /// Raised when two trace segments share the same name.
    #[error("duplicate execution trace segment '{0}'")]
    DuplicateSegment(String),

    /// Raised when a segment declares the same column twice.
    #[error("segment '{segment}' defines duplicate column '{column}'")]
    DuplicateColumn { segment: String, column: String },

    /// Raised when a row has a different width than the declared column count.
    #[error("segment '{segment}' row {row_index} has width {actual}, expected {expected}")]
    InconsistentRowWidth {
        segment: String,
        row_index: usize,
        expected: usize,
        actual: usize,
    },
}

/// Metadata describing a single execution trace segment.
#[derive(Debug)]
pub struct SegmentDescriptor<'a> {
    /// Segment name as declared by the circuit witness.
    pub name: &'a str,
    /// Number of columns contained in the segment.
    pub column_count: usize,
    /// Number of rows contained in the segment.
    pub row_count: usize,
    /// Base-2 logarithm of the row count, rounded up.
    pub log_size: u32,
    /// Mapping between column names and their indices.
    pub column_indices: HashMap<&'a str, usize>,
}

/// Component description tying together the blueprint AIR, trace and
/// parameters with pre-computed segment descriptors.
#[derive(Debug)]
pub struct BlueprintComponent<'a> {
    /// AIR definition generated by the blueprint circuit implementation.
    pub air: &'a AirDefinition,
    /// Execution trace emitted by the blueprint circuit implementation.
    pub trace: &'a ExecutionTrace,
    /// STARK parameters bound to the circuit execution.
    pub parameters: &'a StarkParameters,
    /// Descriptor list for each execution trace segment.
    pub segments: Vec<SegmentDescriptor<'a>>,
    /// Quick lookup from segment name to descriptor index.
    pub segment_lookup: HashMap<&'a str, usize>,
}

impl<'a> BlueprintComponent<'a> {
    /// Create a new adapter component verifying trace metadata and computing
    /// descriptor tables used by the official prover integration.
    pub fn new(
        air: &'a AirDefinition,
        trace: &'a ExecutionTrace,
        parameters: &'a StarkParameters,
    ) -> Result<Self, AdapterError> {
        let mut segment_lookup = HashMap::new();
        let mut segments = Vec::with_capacity(trace.segments.len());

        for (segment_index, segment) in trace.segments.iter().enumerate() {
            register_segment(segment, segment_index, &mut segment_lookup)?;
            segments.push(build_descriptor(segment)?);
        }

        Ok(Self {
            air,
            trace,
            parameters,
            segments,
            segment_lookup,
        })
    }
}

fn register_segment<'a>(
    segment: &'a TraceSegment,
    index: usize,
    lookup: &mut HashMap<&'a str, usize>,
) -> Result<(), AdapterError> {
    let name = segment.name.as_str();
    if lookup.insert(name, index).is_some() {
        return Err(AdapterError::DuplicateSegment(segment.name.clone()));
    }
    Ok(())
}

fn build_descriptor<'a>(segment: &'a TraceSegment) -> Result<SegmentDescriptor<'a>, AdapterError> {
    let column_count = segment.columns.len();
    let mut column_indices = HashMap::with_capacity(column_count);
    for (column_index, column_name) in segment.columns.iter().enumerate() {
        let entry = column_indices.insert(column_name.as_str(), column_index);
        if entry.is_some() {
            return Err(AdapterError::DuplicateColumn {
                segment: segment.name.clone(),
                column: column_name.clone(),
            });
        }
    }

    for (row_index, row) in segment.rows.iter().enumerate() {
        if row.len() != column_count {
            return Err(AdapterError::InconsistentRowWidth {
                segment: segment.name.clone(),
                row_index,
                expected: column_count,
                actual: row.len(),
            });
        }
    }

    let row_count = segment.rows.len();
    let log_size = ceil_log2(row_count);

    Ok(SegmentDescriptor {
        name: segment.name.as_str(),
        column_count,
        row_count,
        log_size,
        column_indices,
    })
}

fn ceil_log2(value: usize) -> u32 {
    match value {
        0 | 1 => 0,
        _ => usize::BITS - (value - 1).leading_zeros(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stwo::circuit::TraceSegment;

    fn sample_segment(name: &str, columns: usize, rows: usize) -> TraceSegment {
        let params = StarkParameters::blueprint_default();
        let mut data = Vec::with_capacity(rows);
        for _ in 0..rows {
            let mut row = Vec::with_capacity(columns);
            for column in 0..columns {
                row.push(params.element_from_u64(column as u64));
            }
            data.push(row);
        }
        TraceSegment::new(name, (0..columns).map(|i| format!("c{i}")).collect(), data)
            .expect("valid segment")
    }

    #[test]
    fn ceil_log2_handles_small_inputs() {
        assert_eq!(ceil_log2(0), 0);
        assert_eq!(ceil_log2(1), 0);
        assert_eq!(ceil_log2(2), 1);
        assert_eq!(ceil_log2(3), 2);
        assert_eq!(ceil_log2(4), 2);
        assert_eq!(ceil_log2(5), 3);
    }

    #[test]
    fn descriptor_rejects_duplicate_columns() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.columns[1] = segment.columns[0].clone();
        let error = build_descriptor(&segment).expect_err("duplicate column");
        match error {
            AdapterError::DuplicateColumn { segment, column } => {
                assert_eq!(segment, "seg");
                assert_eq!(column, "c0");
            }
            _ => panic!("unexpected error: {error:?}"),
        }
    }

    #[test]
    fn descriptor_rejects_inconsistent_rows() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.rows[0].pop();
        let error = build_descriptor(&segment).expect_err("invalid row width");
        assert!(matches!(
            error,
            AdapterError::InconsistentRowWidth {
                segment: _,
                row_index: _,
                expected: _,
                actual: _
            }
        ));
    }

    #[test]
    fn component_detects_duplicate_segments() {
        let segment = sample_segment("seg", 2, 2);
        let trace =
            ExecutionTrace::from_segments(vec![segment.clone(), segment]).expect("valid trace");
        let params = StarkParameters::blueprint_default();
        let air = AirDefinition::new(vec![]);
        let error = BlueprintComponent::new(&air, &trace, &params).expect_err("duplicate segment");
        assert!(matches!(error, AdapterError::DuplicateSegment(_)));
    }
}
