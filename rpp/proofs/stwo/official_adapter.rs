//! Adapter between the blueprint-defined STWO objects and the official prover
//! interfaces.
#![allow(unexpected_cfgs)]
//!
//! The adapter owns references to the blueprint primitives (`AirDefinition`,
//! `ExecutionTrace`, and `StarkParameters`) while pre-computing fast lookup
//! tables for the execution trace segments. These descriptors are used by
//! subsequent trait implementations to bridge the lightweight blueprint models
//! with the official prover APIs.

#[cfg(feature = "stwo/prover")]
use std::collections::BTreeSet;
use std::collections::HashMap;

use thiserror::Error;

use super::{
    air::{AirColumn, AirDefinition, AirExpression, ConstraintDomain, TraceEvaluator},
    circuit::{ExecutionTrace, TraceSegment},
    conversions::{column_to_base, column_to_secure, field_to_secure},
    params::{FieldElement, StarkParameters},
};
use stwo::stwo_official::core::fields::m31::BaseField;
use stwo::stwo_official::core::fields::qm31::{SECURE_EXTENSION_DEGREE, SecureField};
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::core::{
    air::accumulation::PointEvaluationAccumulator,
    circle::CirclePoint,
    constraints::{coset_vanishing, point_vanishing},
};

/// Re-export key prover traits and types from the official STWO implementation
/// so that downstream modules can rely on them without repetitive imports.
pub use stwo::stwo_official::core::{ColumnVec, air::Component, pcs::TreeVec};

#[cfg(feature = "stwo/prover")]
use num_traits::Zero;
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::core::channel::MerkleChannel;
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::core::poly::circle::CanonicCoset;
/// Re-export prover-side structures when the upstream dependency exposes them.
#[cfg(feature = "stwo/prover")]
pub use stwo::stwo_official::prover::{
    air::component_prover::ComponentProver, backend::cpu::CpuBackend,
    poly::circle::CircleEvaluation,
};
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::prover::{
    backend::cpu::{CpuCircleEvaluation, CpuCirclePoly},
    pcs::CommitmentSchemeProver,
    poly::{BitReversedOrder, NaturalOrder},
};

/// Errors that can be raised while validating execution trace descriptors.
#[derive(Debug, Error)]
pub enum AdapterError {
    /// Raised when two trace segments share the same name.
    #[error("duplicate execution trace segment '{0}'")]
    DuplicateSegment(String),

    /// Raised when a segment declares the same column twice.
    #[error("segment '{segment}' defines duplicate column '{column}'")]
    DuplicateColumn { segment: String, column: String },

    /// Raised when a row has a different width than the declared column count.
    #[error("segment '{segment}' row {row_index} has width {actual}, expected {expected}")]
    InconsistentRowWidth {
        segment: String,
        row_index: usize,
        expected: usize,
        actual: usize,
    },
}

/// Metadata describing a single execution trace segment.
#[derive(Debug)]
pub struct SegmentDescriptor<'a> {
    /// Segment name as declared by the circuit witness.
    pub name: &'a str,
    /// Number of columns contained in the segment.
    pub column_count: usize,
    /// Number of rows contained in the segment.
    pub row_count: usize,
    /// Base-2 logarithm of the row count, rounded up.
    pub log_size: u32,
    /// Mapping between column names and their indices.
    pub column_indices: HashMap<&'a str, usize>,
}

#[cfg(feature = "stwo/prover")]
#[derive(Debug, Default)]
struct ColumnMask {
    offsets: Vec<isize>,
    positions: HashMap<isize, usize>,
}

#[cfg(feature = "stwo/prover")]
impl ColumnMask {
    fn new(offsets: Vec<isize>) -> Self {
        let mut unique = offsets;
        if unique.len() > 1 {
            unique.sort_unstable();
            unique.dedup();
        }
        let positions = unique
            .iter()
            .enumerate()
            .map(|(idx, &offset)| (offset, idx))
            .collect();
        Self {
            offsets: unique,
            positions,
        }
    }

    fn offsets(&self) -> &[isize] {
        &self.offsets
    }

    fn index_of(&self, offset: isize) -> Option<usize> {
        self.positions.get(&offset).copied()
    }
}

/// Component description tying together the blueprint AIR, trace and
/// parameters with pre-computed segment descriptors.
#[derive(Debug)]
pub struct BlueprintComponent<'a> {
    /// AIR definition generated by the blueprint circuit implementation.
    pub air: &'a AirDefinition,
    /// Execution trace emitted by the blueprint circuit implementation.
    pub trace: &'a ExecutionTrace,
    /// STARK parameters bound to the circuit execution.
    pub parameters: &'a StarkParameters,
    /// Descriptor list for each execution trace segment.
    pub segments: Vec<SegmentDescriptor<'a>>,
    /// Quick lookup from segment name to descriptor index.
    pub segment_lookup: HashMap<&'a str, usize>,
    #[cfg(feature = "stwo/prover")]
    column_masks: Vec<Vec<ColumnMask>>,
}

impl<'a> BlueprintComponent<'a> {
    /// Create a new adapter component verifying trace metadata and computing
    /// descriptor tables used by the official prover integration.
    pub fn new(
        air: &'a AirDefinition,
        trace: &'a ExecutionTrace,
        parameters: &'a StarkParameters,
    ) -> Result<Self, AdapterError> {
        let mut segment_lookup = HashMap::new();
        let mut segments = Vec::with_capacity(trace.segments.len());

        for (segment_index, segment) in trace.segments.iter().enumerate() {
            register_segment(segment, segment_index, &mut segment_lookup)?;
            segments.push(build_descriptor(segment)?);
        }

        #[cfg(feature = "stwo/prover")]
        let column_masks = build_column_masks(air, &segments, &segment_lookup);

        Ok(Self {
            air,
            trace,
            parameters,
            segments,
            segment_lookup,
            #[cfg(feature = "stwo/prover")]
            column_masks,
        })
    }
}

#[cfg(feature = "stwo/prover")]
fn build_column_masks<'a>(
    air: &'a AirDefinition,
    segments: &[SegmentDescriptor<'a>],
    segment_lookup: &HashMap<&'a str, usize>,
) -> Vec<Vec<ColumnMask>> {
    let mut offsets: Vec<Vec<BTreeSet<isize>>> = segments
        .iter()
        .map(|descriptor| vec![BTreeSet::new(); descriptor.column_count])
        .collect();

    for constraint in air.constraints() {
        collect_expression_offsets(
            &constraint.expression,
            segments,
            segment_lookup,
            &mut offsets,
        );
    }

    offsets
        .into_iter()
        .map(|segment_offsets| {
            segment_offsets
                .into_iter()
                .map(|set| ColumnMask::new(set.into_iter().collect()))
                .collect()
        })
        .collect()
}

#[cfg(feature = "stwo/prover")]
fn collect_expression_offsets<'a>(
    expression: &AirExpression,
    segments: &[SegmentDescriptor<'a>],
    segment_lookup: &HashMap<&'a str, usize>,
    offsets: &mut [Vec<BTreeSet<isize>>],
) {
    match expression {
        AirExpression::Constant(_) => {}
        AirExpression::Column(reference) => {
            let segment = reference.column.segment();
            let column = reference.column.column();
            let segment_index = *segment_lookup
                .get(segment)
                .unwrap_or_else(|| panic!("unknown segment '{segment}'"));
            let descriptor = &segments[segment_index];
            let column_index = *descriptor
                .column_indices
                .get(column)
                .unwrap_or_else(|| panic!("unknown column '{column}' in segment '{segment}'"));
            offsets[segment_index][column_index].insert(reference.offset);
        }
        AirExpression::Add(terms) | AirExpression::Mul(terms) => {
            for term in terms {
                collect_expression_offsets(term, segments, segment_lookup, offsets);
            }
        }
        AirExpression::Sub(lhs, rhs) => {
            collect_expression_offsets(lhs, segments, segment_lookup, offsets);
            collect_expression_offsets(rhs, segments, segment_lookup, offsets);
        }
    }
}

fn column_to_base_field<'a, I>(column: I) -> Vec<BaseField>
where
    I: IntoIterator<Item = &'a FieldElement>,
{
    column_to_base(column)
}

fn column_to_secure_field<'a, I>(column: I) -> Vec<SecureField>
where
    I: IntoIterator<Item = &'a FieldElement>,
{
    column_to_secure(column)
}

#[cfg(feature = "stwo/prover")]
fn segment_tree_index(segment_index: usize) -> usize {
    segment_index + 1
}

#[cfg(feature = "stwo/prover")]
fn secure_to_field(parameters: &StarkParameters, value: &SecureField) -> FieldElement {
    let limbs = value.to_m31_array();
    let mut bytes = [0u8; 4 * SECURE_EXTENSION_DEGREE];
    for (idx, limb) in limbs.iter().enumerate() {
        let limb_bytes = limb.0.to_be_bytes();
        let start = idx * 4;
        bytes[start..start + 4].copy_from_slice(&limb_bytes);
    }
    parameters.element_from_bytes(&bytes)
}

#[cfg(feature = "stwo/prover")]
struct MaskTraceView<'a, 'm> {
    component: &'a BlueprintComponent<'a>,
    parameters: &'a StarkParameters,
    mask: &'m TreeVec<ColumnVec<Vec<SecureField>>>,
}

#[cfg(feature = "stwo/prover")]
impl<'a, 'm> MaskTraceView<'a, 'm> {
    fn new(
        component: &'a BlueprintComponent<'a>,
        parameters: &'a StarkParameters,
        mask: &'m TreeVec<ColumnVec<Vec<SecureField>>>,
    ) -> Self {
        Self {
            component,
            parameters,
            mask,
        }
    }
}

#[cfg(feature = "stwo/prover")]
impl<'a, 'm> TraceEvaluator for MaskTraceView<'a, 'm> {
    fn value(
        &self,
        column: &AirColumn,
        _row: usize,
        offset: isize,
    ) -> Result<FieldElement, super::air::AirError> {
        let segment_name = column.segment();
        let segment_index = *self
            .component
            .segment_lookup
            .get(segment_name)
            .ok_or_else(|| super::air::AirError::MissingSegment(segment_name.to_owned()))?;
        let descriptor = &self.component.segments[segment_index];
        let column_name = column.column();
        let column_index = *descriptor.column_indices.get(column_name).ok_or_else(|| {
            super::air::AirError::MissingColumn {
                segment: segment_name.to_owned(),
                column: column_name.to_owned(),
            }
        })?;
        let mask = &self.component.column_masks[segment_index][column_index];
        let offset_index =
            mask.index_of(offset)
                .ok_or_else(|| super::air::AirError::MissingMaskOffset {
                    segment: segment_name.to_owned(),
                    column: column_name.to_owned(),
                    offset,
                })?;
        let tree_index = segment_tree_index(segment_index);
        let secure_value = self.mask[tree_index][column_index][offset_index].clone();
        Ok(secure_to_field(self.parameters, &secure_value))
    }
}

#[cfg(feature = "stwo/prover")]
fn domain_vanishing(
    descriptor: &SegmentDescriptor<'_>,
    domain: &ConstraintDomain,
    point: CirclePoint<SecureField>,
) -> SecureField {
    let log_size = descriptor.log_size.max(1);
    let coset = CanonicCoset::new(log_size);
    match domain {
        ConstraintDomain::AllRows => coset_vanishing(coset.coset(), point),
        ConstraintDomain::FirstRow => point_vanishing(coset.at(0), point),
        ConstraintDomain::LastRow => {
            let last_row = descriptor.row_count.saturating_sub(1);
            point_vanishing(coset.at(last_row), point)
        }
        ConstraintDomain::Range { .. } => {
            let rows = domain.rows(descriptor.row_count);
            rows.into_iter().fold(SecureField::one(), |acc, row| {
                acc * point_vanishing(coset.at(row), point)
            })
        }
    }
}

fn register_segment<'a>(
    segment: &'a TraceSegment,
    index: usize,
    lookup: &mut HashMap<&'a str, usize>,
) -> Result<(), AdapterError> {
    let name = segment.name.as_str();
    if lookup.insert(name, index).is_some() {
        return Err(AdapterError::DuplicateSegment(segment.name.clone()));
    }
    Ok(())
}

fn build_descriptor<'a>(segment: &'a TraceSegment) -> Result<SegmentDescriptor<'a>, AdapterError> {
    let column_count = segment.columns.len();
    let mut column_indices = HashMap::with_capacity(column_count);
    for (column_index, column_name) in segment.columns.iter().enumerate() {
        let entry = column_indices.insert(column_name.as_str(), column_index);
        if entry.is_some() {
            return Err(AdapterError::DuplicateColumn {
                segment: segment.name.clone(),
                column: column_name.clone(),
            });
        }
    }

    for (row_index, row) in segment.rows.iter().enumerate() {
        if row.len() != column_count {
            return Err(AdapterError::InconsistentRowWidth {
                segment: segment.name.clone(),
                row_index,
                expected: column_count,
                actual: row.len(),
            });
        }
    }

    let row_count = segment.rows.len();
    let log_size = ceil_log2(row_count);

    Ok(SegmentDescriptor {
        name: segment.name.as_str(),
        column_count,
        row_count,
        log_size,
        column_indices,
    })
}

fn ceil_log2(value: usize) -> u32 {
    match value {
        0 | 1 => 0,
        _ => usize::BITS - (value - 1).leading_zeros(),
    }
}

#[cfg(feature = "stwo/prover")]
fn segment_to_circle_evals(
    segment: &TraceSegment,
    descriptor: &SegmentDescriptor<'_>,
) -> ColumnVec<CpuCircleEvaluation<BaseField, BitReversedOrder>> {
    let log_size = descriptor.log_size.max(1);
    let domain = CanonicCoset::new(log_size).circle_domain();
    let domain_size = domain.size();

    (0..descriptor.column_count)
        .map(|column_index| {
            let column_iter = segment.rows.iter().map(|row| &row[column_index]);
            let mut values = column_to_base_field(column_iter);
            values.resize(domain_size, BaseField::zero());
            CpuCircleEvaluation::<BaseField, NaturalOrder>::new(domain, values).bit_reverse()
        })
        .collect()
}

#[cfg(feature = "stwo/prover")]
#[derive(Debug)]
pub struct TraceCommitmentViews<'a> {
    pub polynomials: TreeVec<ColumnVec<&'a CpuCirclePoly>>,
    pub evaluations: TreeVec<ColumnVec<&'a CpuCircleEvaluation<BaseField, BitReversedOrder>>>,
}

#[cfg(feature = "stwo/prover")]
impl<'a> BlueprintComponent<'a> {
    pub fn build_commitment_views<'b, 'c, MC: MerkleChannel>(
        &self,
        commitment_scheme: &'b mut CommitmentSchemeProver<'c, CpuBackend, MC>,
        channel: &mut MC::C,
    ) -> TraceCommitmentViews<'b> {
        for (segment, descriptor) in self.trace.segments.iter().zip(&self.segments) {
            let evaluations = segment_to_circle_evals(segment, descriptor);
            let mut builder = commitment_scheme.tree_builder();
            builder.extend_evals(evaluations);
            builder.commit(channel);
        }

        let polynomials = prepend_preprocessed_tree(commitment_scheme.polynomials());
        let evaluations = prepend_preprocessed_tree(commitment_scheme.evaluations());

        TraceCommitmentViews {
            polynomials,
            evaluations,
        }
    }
}

#[cfg(feature = "stwo/prover")]
fn prepend_preprocessed_tree<T>(views: TreeVec<ColumnVec<T>>) -> TreeVec<ColumnVec<T>> {
    let mut trees = Vec::with_capacity(views.len() + 1);
    trees.push(Vec::new());
    trees.extend(views.0);
    TreeVec(trees)
}

#[cfg(feature = "stwo/prover")]
impl<'a> Component for BlueprintComponent<'a> {
    fn n_constraints(&self) -> usize {
        self.air.constraints().len()
    }

    fn max_constraint_log_degree_bound(&self) -> u32 {
        let mut max_log = 1;
        for constraint in self.air.constraints() {
            let segment_index = *self
                .segment_lookup
                .get(constraint.segment.as_str())
                .expect("segment registered");
            let descriptor = &self.segments[segment_index];
            let domain_len = match &constraint.domain {
                ConstraintDomain::AllRows => {
                    let log_size = descriptor.log_size.max(1);
                    1usize << log_size
                }
                _ => {
                    let rows = constraint.domain.rows(descriptor.row_count);
                    let len = rows.len();
                    if len == 0 { 1 } else { len }
                }
            };
            let bound = ceil_log2(domain_len).max(1);
            max_log = max_log.max(bound);
        }
        max_log
    }

    fn trace_log_degree_bounds(&self) -> TreeVec<ColumnVec<u32>> {
        let mut trees = Vec::with_capacity(self.segments.len() + 1);
        trees.push(Vec::new());
        for descriptor in &self.segments {
            let log_size = descriptor.log_size.max(1);
            trees.push(vec![log_size; descriptor.column_count]);
        }
        TreeVec(trees)
    }

    fn mask_points(
        &self,
        point: CirclePoint<SecureField>,
    ) -> TreeVec<ColumnVec<Vec<CirclePoint<SecureField>>>> {
        let mut trees = Vec::with_capacity(self.segments.len() + 1);
        trees.push(Vec::new());
        for (descriptor, column_masks) in self.segments.iter().zip(&self.column_masks) {
            let log_size = descriptor.log_size.max(1);
            let step = CanonicCoset::new(log_size).step();
            let columns = column_masks
                .iter()
                .map(|mask| {
                    mask.offsets()
                        .iter()
                        .map(|&offset| point + step.mul_signed(offset).into_ef())
                        .collect()
                })
                .collect();
            trees.push(columns);
        }
        TreeVec(trees)
    }

    fn preprocessed_column_indices(&self) -> ColumnVec<usize> {
        // Blueprint circuits currently do not define preprocessed trace columns.
        vec![]
    }

    fn evaluate_constraint_quotients_at_point(
        &self,
        point: CirclePoint<SecureField>,
        mask: &TreeVec<ColumnVec<Vec<SecureField>>>,
        evaluation_accumulator: &mut PointEvaluationAccumulator,
    ) {
        let mask_view = MaskTraceView::new(self, self.parameters, mask);
        for constraint in self.air.constraints() {
            let segment_index = *self
                .segment_lookup
                .get(constraint.segment.as_str())
                .expect("segment registered");
            let descriptor = &self.segments[segment_index];
            let numerator_field = constraint
                .expression
                .evaluate(&mask_view, 0, self.parameters)
                .unwrap_or_else(|err| {
                    panic!("failed to evaluate constraint '{}': {err}", constraint.name)
                });
            let numerator = field_to_secure(&numerator_field);
            let denominator = domain_vanishing(descriptor, &constraint.domain, point);
            let evaluation = numerator * denominator.inverse();
            evaluation_accumulator.accumulate(evaluation);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stwo::circuit::TraceSegment;
    #[cfg(feature = "stwo/prover")]
    use stwo::stwo_official::core::fields::m31::BaseField;

    fn sample_segment(name: &str, columns: usize, rows: usize) -> TraceSegment {
        let params = StarkParameters::blueprint_default();
        let mut data = Vec::with_capacity(rows);
        for _ in 0..rows {
            let mut row = Vec::with_capacity(columns);
            for column in 0..columns {
                row.push(params.element_from_u64(column as u64));
            }
            data.push(row);
        }
        TraceSegment::new(name, (0..columns).map(|i| format!("c{i}")).collect(), data)
            .expect("valid segment")
    }

    #[test]
    fn column_conversion_preserves_lengths() {
        let segment = sample_segment("seg", 2, 3);
        let base_values = super::column_to_base_field(segment.rows.iter().map(|row| &row[0]));
        let secure_values = super::column_to_secure_field(segment.rows.iter().map(|row| &row[0]));
        assert_eq!(base_values.len(), 3);
        assert_eq!(secure_values.len(), 3);
    }

    #[cfg(feature = "stwo/prover")]
    #[test]
    fn segment_evaluations_pad_to_power_of_two() {
        use num_traits::Zero;

        let segment = sample_segment("seg", 1, 3);
        let descriptor = super::build_descriptor(&segment).expect("valid descriptor");
        let evaluations = super::segment_to_circle_evals(&segment, &descriptor);
        assert_eq!(evaluations.len(), 1);
        let evaluation = &evaluations[0];
        assert_eq!(evaluation.domain.size(), 1 << descriptor.log_size.max(1));
        assert_eq!(evaluation.values.len(), evaluation.domain.size());
        assert_eq!(
            evaluation.values[evaluation.values.len() - 1],
            BaseField::zero()
        );
    }

    #[test]
    fn ceil_log2_handles_small_inputs() {
        assert_eq!(ceil_log2(0), 0);
        assert_eq!(ceil_log2(1), 0);
        assert_eq!(ceil_log2(2), 1);
        assert_eq!(ceil_log2(3), 2);
        assert_eq!(ceil_log2(4), 2);
        assert_eq!(ceil_log2(5), 3);
    }

    #[test]
    fn descriptor_rejects_duplicate_columns() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.columns[1] = segment.columns[0].clone();
        let error = build_descriptor(&segment).expect_err("duplicate column");
        match error {
            AdapterError::DuplicateColumn { segment, column } => {
                assert_eq!(segment, "seg");
                assert_eq!(column, "c0");
            }
            _ => panic!("unexpected error: {error:?}"),
        }
    }

    #[test]
    fn descriptor_rejects_inconsistent_rows() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.rows[0].pop();
        let error = build_descriptor(&segment).expect_err("invalid row width");
        assert!(matches!(
            error,
            AdapterError::InconsistentRowWidth {
                segment: _,
                row_index: _,
                expected: _,
                actual: _
            }
        ));
    }

    #[test]
    fn component_detects_duplicate_segments() {
        let segment = sample_segment("seg", 2, 2);
        let trace =
            ExecutionTrace::from_segments(vec![segment.clone(), segment]).expect("valid trace");
        let params = StarkParameters::blueprint_default();
        let air = AirDefinition::new(vec![]);
        let error = BlueprintComponent::new(&air, &trace, &params).expect_err("duplicate segment");
        assert!(matches!(error, AdapterError::DuplicateSegment(_)));
    }
}
