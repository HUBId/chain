//! Adapter between the blueprint-defined STWO objects and the official prover
//! interfaces.
#![allow(unexpected_cfgs)]
//!
//! The adapter owns references to the blueprint primitives (`AirDefinition`,
//! `ExecutionTrace`, and `StarkParameters`) while pre-computing fast lookup
//! tables for the execution trace segments. These descriptors are used by
//! subsequent trait implementations to bridge the lightweight blueprint models
//! with the official prover APIs.

#[cfg(feature = "backend-stwo")]
use std::collections::BTreeSet;
use std::collections::HashMap;

use thiserror::Error;

use super::{
    air::{AirColumn, AirDefinition, AirExpression, ConstraintDomain, TraceEvaluator},
    circuit::{ExecutionTrace, TraceSegment},
    conversions::{column_to_base, field_to_secure},
    params::{FieldElement, StarkParameters},
};
use stwo::stwo_official::core::fields::m31::BaseField;
use stwo::stwo_official::core::fields::qm31::{SECURE_EXTENSION_DEGREE, SecureField};
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::core::{
    air::accumulation::PointEvaluationAccumulator,
    circle::CirclePoint,
    constraints::{coset_vanishing, point_vanishing},
};

/// Re-export key prover traits and types from the official STWO implementation
/// so that downstream modules can rely on them without repetitive imports.
pub use stwo::stwo_official::core::{ColumnVec, air::Component, pcs::TreeVec};

#[cfg(feature = "backend-stwo")]
use num_traits::{One, Zero};
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::core::channel::MerkleChannel;
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::core::fields::FieldExpOps;
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::core::poly::circle::{CanonicCoset, CircleDomain};
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::core::utils::{
    bit_reverse_index, offset_bit_reversed_circle_domain_index,
};
#[cfg(feature = "backend-stwo")]
pub use stwo::stwo_official::prover::poly::circle::CircleEvaluation;
/// Re-export prover-side structures when the upstream dependency exposes them.
#[cfg(feature = "backend-stwo")]
pub use stwo::stwo_official::prover::{
    CommitmentSchemeProver, CommitmentTreeProver, ComponentProver, ComponentProvers,
    DomainEvaluationAccumulator, Trace, TreeBuilder, backend::cpu::CpuBackend,
};
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::prover::{backend::BackendForChannel, poly::circle::PolyOps};
#[cfg(feature = "backend-stwo")]
use stwo::stwo_official::prover::{
    backend::cpu::{CpuCircleEvaluation, CpuCirclePoly},
    poly::twiddles::TwiddleTree,
    poly::{BitReversedOrder, NaturalOrder},
};

/// Errors that can be raised while validating execution trace descriptors.
#[derive(Debug, Error)]
pub enum AdapterError {
    /// Raised when two trace segments share the same name.
    #[error("duplicate execution trace segment '{0}'")]
    DuplicateSegment(String),

    /// Raised when a segment declares the same column twice.
    #[error("segment '{segment}' defines duplicate column '{column}'")]
    DuplicateColumn { segment: String, column: String },

    /// Raised when a row has a different width than the declared column count.
    #[error("segment '{segment}' row {row_index} has width {actual}, expected {expected}")]
    InconsistentRowWidth {
        segment: String,
        row_index: usize,
        expected: usize,
        actual: usize,
    },
}

/// Metadata describing a single execution trace segment.
#[derive(Debug)]
pub struct SegmentDescriptor<'a> {
    /// Segment name as declared by the circuit witness.
    pub name: &'a str,
    /// Number of columns contained in the segment.
    pub column_count: usize,
    /// Number of rows contained in the segment.
    pub row_count: usize,
    /// Base-2 logarithm of the row count, rounded up.
    pub log_size: u32,
    /// Mapping between column names and their indices.
    pub column_indices: HashMap<&'a str, usize>,
}

#[cfg(feature = "backend-stwo")]
#[derive(Debug, Default)]
struct ColumnMask {
    offsets: Vec<isize>,
    positions: HashMap<isize, usize>,
}

#[cfg(feature = "backend-stwo")]
impl ColumnMask {
    fn new(offsets: Vec<isize>) -> Self {
        let mut unique = offsets;
        if unique.len() > 1 {
            unique.sort_unstable();
            unique.dedup();
        }
        let positions = unique
            .iter()
            .enumerate()
            .map(|(idx, &offset)| (offset, idx))
            .collect();
        Self {
            offsets: unique,
            positions,
        }
    }

    fn offsets(&self) -> &[isize] {
        &self.offsets
    }

    fn index_of(&self, offset: isize) -> Option<usize> {
        self.positions.get(&offset).copied()
    }
}

/// Component description tying together the blueprint AIR, trace and
/// parameters with pre-computed segment descriptors.
#[derive(Debug)]
pub struct BlueprintComponent<'a> {
    /// AIR definition generated by the blueprint circuit implementation.
    pub air: &'a AirDefinition,
    /// Execution trace emitted by the blueprint circuit implementation.
    pub trace: &'a ExecutionTrace,
    /// STARK parameters bound to the circuit execution.
    pub parameters: &'a StarkParameters,
    /// Descriptor list for each execution trace segment.
    pub segments: Vec<SegmentDescriptor<'a>>,
    /// Quick lookup from segment name to descriptor index.
    pub segment_lookup: HashMap<&'a str, usize>,
    #[cfg(feature = "backend-stwo")]
    column_masks: Vec<Vec<ColumnMask>>,
}

impl<'a> BlueprintComponent<'a> {
    /// Create a new adapter component verifying trace metadata and computing
    /// descriptor tables used by the official prover integration.
    pub fn new(
        air: &'a AirDefinition,
        trace: &'a ExecutionTrace,
        parameters: &'a StarkParameters,
    ) -> Result<Self, AdapterError> {
        let mut segment_lookup = HashMap::new();
        let mut segments = Vec::with_capacity(trace.segments.len());

        for (segment_index, segment) in trace.segments.iter().enumerate() {
            register_segment(segment, segment_index, &mut segment_lookup)?;
            segments.push(build_descriptor(segment)?);
        }

        #[cfg(feature = "backend-stwo")]
        let column_masks = build_column_masks(air, &segments, &segment_lookup);

        Ok(Self {
            air,
            trace,
            parameters,
            segments,
            segment_lookup,
            #[cfg(feature = "backend-stwo")]
            column_masks,
        })
    }

    /// Returns a list of verifier components referencing the underlying AIR
    /// definition and execution trace data.
    pub fn verifier_components(&'a self) -> Vec<&'a dyn Component> {
        vec![self as &dyn Component]
    }
}

#[cfg(feature = "backend-stwo")]
fn build_column_masks<'a>(
    air: &'a AirDefinition,
    segments: &[SegmentDescriptor<'a>],
    segment_lookup: &HashMap<&'a str, usize>,
) -> Vec<Vec<ColumnMask>> {
    let mut offsets: Vec<Vec<BTreeSet<isize>>> = segments
        .iter()
        .map(|descriptor| vec![BTreeSet::new(); descriptor.column_count])
        .collect();

    for constraint in air.constraints() {
        collect_expression_offsets(
            &constraint.expression,
            segments,
            segment_lookup,
            &mut offsets,
        );
    }

    offsets
        .into_iter()
        .map(|segment_offsets| {
            segment_offsets
                .into_iter()
                .map(|set| ColumnMask::new(set.into_iter().collect()))
                .collect()
        })
        .collect()
}

#[cfg(feature = "backend-stwo")]
fn collect_expression_offsets<'a>(
    expression: &AirExpression,
    segments: &[SegmentDescriptor<'a>],
    segment_lookup: &HashMap<&'a str, usize>,
    offsets: &mut [Vec<BTreeSet<isize>>],
) {
    match expression {
        AirExpression::Constant(_) => {}
        AirExpression::Column(reference) => {
            let column_ref = reference.column();
            let segment = column_ref.segment();
            let column = column_ref.column();
            let segment_index = *segment_lookup
                .get(segment)
                .unwrap_or_else(|| panic!("unknown segment '{segment}'"));
            let descriptor = &segments[segment_index];
            let column_index = *descriptor
                .column_indices
                .get(column)
                .unwrap_or_else(|| panic!("unknown column '{column}' in segment '{segment}'"));
            offsets[segment_index][column_index].insert(reference.offset());
        }
        AirExpression::Add(terms) | AirExpression::Mul(terms) => {
            for term in terms {
                collect_expression_offsets(term, segments, segment_lookup, offsets);
            }
        }
        AirExpression::Sub(lhs, rhs) => {
            collect_expression_offsets(lhs, segments, segment_lookup, offsets);
            collect_expression_offsets(rhs, segments, segment_lookup, offsets);
        }
    }
}

fn column_to_base_field<'a, I>(column: I) -> Vec<BaseField>
where
    I: IntoIterator<Item = &'a FieldElement>,
{
    column_to_base(column)
}

#[cfg(feature = "backend-stwo")]
fn segment_tree_index(segment_index: usize) -> usize {
    segment_index + 1
}

#[cfg(feature = "backend-stwo")]
fn secure_to_field(parameters: &StarkParameters, value: &SecureField) -> FieldElement {
    let limbs = value.to_m31_array();
    let mut bytes = [0u8; 4 * SECURE_EXTENSION_DEGREE];
    for (idx, limb) in limbs.iter().enumerate() {
        let limb_bytes = limb.0.to_be_bytes();
        let start = idx * 4;
        bytes[start..start + 4].copy_from_slice(&limb_bytes);
    }
    parameters.element_from_bytes(&bytes)
}

#[cfg(feature = "backend-stwo")]
struct MaskTraceView<'a, 'm> {
    component: &'a BlueprintComponent<'a>,
    parameters: &'a StarkParameters,
    mask: &'m TreeVec<ColumnVec<Vec<SecureField>>>,
}

#[cfg(feature = "backend-stwo")]
impl<'a, 'm> MaskTraceView<'a, 'm> {
    fn new(
        component: &'a BlueprintComponent<'a>,
        parameters: &'a StarkParameters,
        mask: &'m TreeVec<ColumnVec<Vec<SecureField>>>,
    ) -> Self {
        Self {
            component,
            parameters,
            mask,
        }
    }
}

#[cfg(feature = "backend-stwo")]
impl<'a, 'm> TraceEvaluator for MaskTraceView<'a, 'm> {
    fn value(
        &self,
        column: &AirColumn,
        _row: usize,
        offset: isize,
    ) -> Result<FieldElement, super::air::AirError> {
        let segment_name = column.segment();
        let segment_index = *self
            .component
            .segment_lookup
            .get(segment_name)
            .ok_or_else(|| super::air::AirError::MissingSegment(segment_name.to_owned()))?;
        let descriptor = &self.component.segments[segment_index];
        let column_name = column.column();
        let column_index = *descriptor.column_indices.get(column_name).ok_or_else(|| {
            super::air::AirError::MissingColumn {
                segment: segment_name.to_owned(),
                column: column_name.to_owned(),
            }
        })?;
        let mask = &self.component.column_masks[segment_index][column_index];
        let offset_index =
            mask.index_of(offset)
                .ok_or_else(|| super::air::AirError::MissingMaskOffset {
                    segment: segment_name.to_owned(),
                    column: column_name.to_owned(),
                    offset,
                })?;
        let tree_index = segment_tree_index(segment_index);
        let secure_value = self.mask[tree_index][column_index][offset_index].clone();
        Ok(secure_to_field(self.parameters, &secure_value))
    }
}

#[cfg(feature = "backend-stwo")]
enum ColumnDomainValues<'a> {
    Borrowed(&'a [BaseField]),
    Owned(Vec<BaseField>),
}

#[cfg(feature = "backend-stwo")]
impl<'a> ColumnDomainValues<'a> {
    fn len(&self) -> usize {
        match self {
            ColumnDomainValues::Borrowed(values) => values.len(),
            ColumnDomainValues::Owned(values) => values.len(),
        }
    }

    fn value(&self, index: usize) -> BaseField {
        match self {
            ColumnDomainValues::Borrowed(values) => values[index],
            ColumnDomainValues::Owned(values) => values[index],
        }
    }
}

#[cfg(feature = "backend-stwo")]
struct SegmentDomainValues<'a, 't> {
    descriptor: &'a SegmentDescriptor<'a>,
    log_size: u32,
    columns: Vec<ColumnDomainValues<'t>>,
}

#[cfg(feature = "backend-stwo")]
struct DomainTraceView<'a, 't> {
    component: &'a BlueprintComponent<'a>,
    parameters: &'a StarkParameters,
    eval_log_size: u32,
    segments: Vec<SegmentDomainValues<'a, 't>>,
}

#[cfg(feature = "backend-stwo")]
impl<'a, 't> DomainTraceView<'a, 't> {
    fn new(
        component: &'a BlueprintComponent<'a>,
        parameters: &'a StarkParameters,
        trace: &'t Trace<'t, CpuBackend>,
        eval_log_size: u32,
        eval_domain: Option<CircleDomain>,
        twiddles: Option<&TwiddleTree<CpuBackend>>,
        expected_len: usize,
    ) -> Self {
        let mut segments = Vec::with_capacity(component.segments.len());
        for (segment_index, descriptor) in component.segments.iter().enumerate() {
            let tree_index = segment_tree_index(segment_index);
            let mut columns = Vec::with_capacity(descriptor.column_count);
            for column_index in 0..descriptor.column_count {
                let eval_ref = trace.evals[tree_index][column_index];
                let values = if let Some(domain) = eval_domain {
                    if eval_ref.domain == domain {
                        ColumnDomainValues::Borrowed(eval_ref.values.as_slice())
                    } else {
                        let twiddles = twiddles.expect("evaluation twiddles available");
                        let poly = trace.polys[tree_index][column_index];
                        let extended = poly.evaluate_with_twiddles(domain, twiddles);
                        ColumnDomainValues::Owned(extended.values)
                    }
                } else {
                    ColumnDomainValues::Borrowed(eval_ref.values.as_slice())
                };
                if eval_domain.is_some() {
                    debug_assert_eq!(values.len(), expected_len);
                }
                columns.push(values);
            }
            segments.push(SegmentDomainValues {
                descriptor,
                log_size: descriptor.log_size.max(1),
                columns,
            });
        }
        Self {
            component,
            parameters,
            eval_log_size,
            segments,
        }
    }
}

#[cfg(feature = "backend-stwo")]
impl<'a, 't> TraceEvaluator for DomainTraceView<'a, 't> {
    fn value(
        &self,
        column: &AirColumn,
        row: usize,
        offset: isize,
    ) -> Result<FieldElement, super::air::AirError> {
        let segment_name = column.segment();
        let segment_index = *self
            .component
            .segment_lookup
            .get(segment_name)
            .ok_or_else(|| super::air::AirError::MissingSegment(segment_name.to_owned()))?;
        let segment = &self.segments[segment_index];
        let descriptor = segment.descriptor;
        let column_name = column.column();
        let column_index = *descriptor.column_indices.get(column_name).ok_or_else(|| {
            super::air::AirError::MissingColumn {
                segment: segment_name.to_owned(),
                column: column_name.to_owned(),
            }
        })?;
        let values = &segment.columns[column_index];
        let len = values.len();
        let index = map_domain_index(row, offset, segment.log_size, self.eval_log_size, len)
            .ok_or_else(|| super::air::AirError::RowOutOfBounds {
                segment: segment_name.to_owned(),
                column: column_name.to_owned(),
                row,
                offset,
            })?;
        let base_value = values.value(index);
        Ok(self.parameters.element_from_u64(base_value.0 as u64))
    }
}

#[cfg(feature = "backend-stwo")]
fn map_domain_index(
    row: usize,
    offset: isize,
    domain_log_size: u32,
    eval_log_size: u32,
    len: usize,
) -> Option<usize> {
    if offset == 0 {
        return (row < len).then_some(row);
    }
    if eval_log_size == domain_log_size {
        let natural = bit_reverse_index(row, eval_log_size);
        let domain_size = 1usize << domain_log_size;
        let target = natural as isize + offset;
        if !(0..domain_size as isize).contains(&target) {
            return None;
        }
        Some(bit_reverse_index(target as usize, eval_log_size))
    } else {
        let index =
            offset_bit_reversed_circle_domain_index(row, domain_log_size, eval_log_size, offset);
        (index < len).then_some(index)
    }
}

#[cfg(feature = "backend-stwo")]
fn domain_vanishing(
    descriptor: &SegmentDescriptor<'_>,
    domain: &ConstraintDomain,
    point: CirclePoint<SecureField>,
) -> SecureField {
    let log_size = descriptor.log_size.max(1);
    let coset = CanonicCoset::new(log_size);
    match domain {
        ConstraintDomain::AllRows => coset_vanishing(coset.coset(), point),
        ConstraintDomain::FirstRow => point_vanishing(coset.at(0), point),
        ConstraintDomain::LastRow => {
            let last_row = descriptor.row_count.saturating_sub(1);
            point_vanishing(coset.at(last_row), point)
        }
        ConstraintDomain::Range { .. } => {
            let rows = domain.rows(descriptor.row_count);
            rows.into_iter().fold(SecureField::one(), |acc, row| {
                acc * point_vanishing(coset.at(row), point)
            })
        }
    }
}

fn register_segment<'a>(
    segment: &'a TraceSegment,
    index: usize,
    lookup: &mut HashMap<&'a str, usize>,
) -> Result<(), AdapterError> {
    let name = segment.name.as_str();
    if lookup.insert(name, index).is_some() {
        return Err(AdapterError::DuplicateSegment(segment.name.clone()));
    }
    Ok(())
}

fn build_descriptor<'a>(segment: &'a TraceSegment) -> Result<SegmentDescriptor<'a>, AdapterError> {
    let column_count = segment.columns.len();
    let mut column_indices = HashMap::with_capacity(column_count);
    for (column_index, column_name) in segment.columns.iter().enumerate() {
        let entry = column_indices.insert(column_name.as_str(), column_index);
        if entry.is_some() {
            return Err(AdapterError::DuplicateColumn {
                segment: segment.name.clone(),
                column: column_name.clone(),
            });
        }
    }

    for (row_index, row) in segment.rows.iter().enumerate() {
        if row.len() != column_count {
            return Err(AdapterError::InconsistentRowWidth {
                segment: segment.name.clone(),
                row_index,
                expected: column_count,
                actual: row.len(),
            });
        }
    }

    let row_count = segment.rows.len();
    let log_size = ceil_log2(row_count);

    Ok(SegmentDescriptor {
        name: segment.name.as_str(),
        column_count,
        row_count,
        log_size,
        column_indices,
    })
}

fn ceil_log2(value: usize) -> u32 {
    match value {
        0 | 1 => 0,
        _ => usize::BITS - (value - 1).leading_zeros(),
    }
}

#[cfg(feature = "backend-stwo")]
fn segment_to_circle_evals(
    segment: &TraceSegment,
    descriptor: &SegmentDescriptor<'_>,
) -> ColumnVec<CpuCircleEvaluation<BaseField, BitReversedOrder>> {
    let log_size = descriptor.log_size.max(1);
    let domain = CanonicCoset::new(log_size).circle_domain();
    let domain_size = domain.size();

    (0..descriptor.column_count)
        .map(|column_index| {
            let column_iter = segment.rows.iter().map(|row| &row[column_index]);
            let mut values = column_to_base_field(column_iter);
            values.resize(domain_size, BaseField::zero());
            CpuCircleEvaluation::<BaseField, NaturalOrder>::new(domain, values).bit_reverse()
        })
        .collect()
}

#[cfg(feature = "backend-stwo")]
#[derive(Debug)]
pub struct TraceCommitmentViews<'a> {
    pub polynomials: TreeVec<ColumnVec<&'a CpuCirclePoly>>,
    pub evaluations: TreeVec<ColumnVec<&'a CpuCircleEvaluation<BaseField, BitReversedOrder>>>,
}

#[cfg(feature = "backend-stwo")]
impl<'a> BlueprintComponent<'a> {
    pub fn build_commitment_views<'b, 'c, MC: MerkleChannel>(
        &self,
        commitment_scheme: &'b mut CommitmentSchemeProver<'c, CpuBackend, MC>,
        channel: &mut MC::C,
    ) -> TraceCommitmentViews<'b>
    where
        CpuBackend: BackendForChannel<MC>,
    {
        for (segment, descriptor) in self.trace.segments.iter().zip(&self.segments) {
            let evaluations = segment_to_circle_evals(segment, descriptor);
            let mut builder = commitment_scheme.tree_builder();
            builder.extend_evals(evaluations);
            builder.commit(channel);
        }

        let polynomials = prepend_preprocessed_tree(commitment_scheme.polynomials());
        let evaluations = prepend_preprocessed_tree(commitment_scheme.evaluations());

        TraceCommitmentViews {
            polynomials,
            evaluations,
        }
    }
}

#[cfg(feature = "backend-stwo")]
fn prepend_preprocessed_tree<T>(views: TreeVec<ColumnVec<T>>) -> TreeVec<ColumnVec<T>> {
    let mut trees = Vec::with_capacity(views.len() + 1);
    trees.push(Vec::new());
    trees.extend(views.0);
    TreeVec(trees)
}

#[cfg(feature = "backend-stwo")]
impl<'a> Component for BlueprintComponent<'a> {
    fn n_constraints(&self) -> usize {
        self.air.constraints().len()
    }

    fn max_constraint_log_degree_bound(&self) -> u32 {
        let mut max_log = 1;
        for constraint in self.air.constraints() {
            let segment_index = *self
                .segment_lookup
                .get(constraint.segment.as_str())
                .expect("segment registered");
            let descriptor = &self.segments[segment_index];
            let domain_len = match &constraint.domain {
                ConstraintDomain::AllRows => {
                    let log_size = descriptor.log_size.max(1);
                    1usize << log_size
                }
                _ => {
                    let rows = constraint.domain.rows(descriptor.row_count);
                    let len = rows.len();
                    if len == 0 { 1 } else { len }
                }
            };
            let bound = ceil_log2(domain_len).max(1);
            max_log = max_log.max(bound);
        }
        max_log
    }

    fn trace_log_degree_bounds(&self) -> TreeVec<ColumnVec<u32>> {
        let mut trees = Vec::with_capacity(self.segments.len() + 1);
        trees.push(Vec::new());
        for descriptor in &self.segments {
            let log_size = descriptor.log_size.max(1);
            trees.push(vec![log_size; descriptor.column_count]);
        }
        TreeVec(trees)
    }

    fn mask_points(
        &self,
        point: CirclePoint<SecureField>,
    ) -> TreeVec<ColumnVec<Vec<CirclePoint<SecureField>>>> {
        let mut trees = Vec::with_capacity(self.segments.len() + 1);
        trees.push(Vec::new());
        for (descriptor, column_masks) in self.segments.iter().zip(&self.column_masks) {
            let log_size = descriptor.log_size.max(1);
            let step = CanonicCoset::new(log_size).step();
            let columns = column_masks
                .iter()
                .map(|mask| {
                    mask.offsets()
                        .iter()
                        .map(|&offset| point + step.mul_signed(offset).into_ef())
                        .collect()
                })
                .collect();
            trees.push(columns);
        }
        TreeVec(trees)
    }

    fn preprocessed_column_indices(&self) -> ColumnVec<usize> {
        // Blueprint circuits currently do not define preprocessed trace columns.
        vec![]
    }

    fn evaluate_constraint_quotients_at_point(
        &self,
        point: CirclePoint<SecureField>,
        mask: &TreeVec<ColumnVec<Vec<SecureField>>>,
        evaluation_accumulator: &mut PointEvaluationAccumulator,
    ) {
        let mask_view = MaskTraceView::new(self, self.parameters, mask);
        for constraint in self.air.constraints() {
            let segment_index = *self
                .segment_lookup
                .get(constraint.segment.as_str())
                .expect("segment registered");
            let descriptor = &self.segments[segment_index];
            let numerator_field = constraint
                .expression
                .evaluate(&mask_view, 0, self.parameters)
                .unwrap_or_else(|err| {
                    panic!("failed to evaluate constraint '{}': {err}", constraint.name)
                });
            let numerator = field_to_secure(&numerator_field);
            let denominator = domain_vanishing(descriptor, &constraint.domain, point);
            let evaluation = numerator * denominator.inverse();
            evaluation_accumulator.accumulate(evaluation);
        }
    }
}

#[cfg(feature = "backend-stwo")]
impl<'a> ComponentProver<CpuBackend> for BlueprintComponent<'a> {
    fn evaluate_constraint_quotients_on_domain(
        &self,
        trace: &Trace<'_, CpuBackend>,
        evaluation_accumulator: &mut DomainEvaluationAccumulator<CpuBackend>,
    ) {
        if self.n_constraints() == 0 {
            return;
        }

        let max_log = self.max_constraint_log_degree_bound();
        let (eval_domain, twiddles, eval_size) = if max_log == 0 {
            (None, None, 1usize)
        } else {
            let domain = CanonicCoset::new(max_log).circle_domain();
            let size = domain.size();
            let twiddles = CpuBackend::precompute_twiddles(domain.half_coset);
            (Some(domain), Some(twiddles), size)
        };
        let domain_log_size = eval_domain
            .map(|domain| domain.log_size())
            .unwrap_or(max_log);

        let [mut accum] = evaluation_accumulator.columns([(max_log, self.n_constraints())]);
        accum.random_coeff_powers.reverse();

        let trace_view = DomainTraceView::new(
            self,
            self.parameters,
            trace,
            domain_log_size,
            eval_domain,
            twiddles.as_ref(),
            eval_size,
        );

        for row in 0..eval_size {
            let mut row_value = SecureField::zero();
            let eval_point = eval_domain
                .map(|domain| domain.at(row).into_ef())
                .unwrap_or_else(CirclePoint::<SecureField>::zero);
            for (constraint_idx, constraint) in self.air.constraints().iter().enumerate() {
                let numerator_field = constraint
                    .expression
                    .evaluate(&trace_view, row, self.parameters)
                    .unwrap_or_else(|err| {
                        panic!("failed to evaluate constraint '{}': {err}", constraint.name)
                    });
                let numerator = field_to_secure(&numerator_field);
                if numerator.is_zero() {
                    continue;
                }

                let segment_index = *self
                    .segment_lookup
                    .get(constraint.segment.as_str())
                    .expect("segment registered");
                let descriptor = &self.segments[segment_index];
                let denominator = domain_vanishing(descriptor, &constraint.domain, eval_point);
                if denominator.is_zero() {
                    // Single-row segments (log_size = 0) are evaluated on the same coset as the
                    // committed trace, so their vanishing polynomial evaluates to zero. The
                    // corresponding constraints must already vanish on that row; otherwise the
                    // trace is invalid and we stop early.
                    debug_assert_eq!(
                        descriptor.log_size, 0,
                        "vanishing denominator on multi-row segment"
                    );
                    panic!(
                        "constraint '{}' produced non-zero value on single-row segment",
                        constraint.name
                    );
                }
                let quotient = numerator * denominator.inverse();
                let coeff = accum.random_coeff_powers[constraint_idx].clone();
                row_value += coeff * quotient;
            }
            if !row_value.is_zero() {
                accum.accumulate(row, row_value);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::{Component, ComponentProver};
    use crate::stwo::air::{
        AirColumn, AirConstraint, AirDefinition, AirExpression, ConstraintDomain,
    };
    use crate::stwo::circuit::TraceSegment;
    use crate::stwo::conversions::column_to_secure;
    #[cfg(feature = "backend-stwo")]
    use stwo::stwo_official::core::fields::m31::BaseField;
    #[cfg(feature = "backend-stwo")]
    use stwo::stwo_official::core::fields::qm31::SecureField;
    #[cfg(feature = "backend-stwo")]
    use stwo::stwo_official::prover::{DomainEvaluationAccumulator, Trace};

    fn sample_segment(name: &str, columns: usize, rows: usize) -> TraceSegment {
        let params = StarkParameters::blueprint_default();
        let mut data = Vec::with_capacity(rows);
        for _ in 0..rows {
            let mut row = Vec::with_capacity(columns);
            for column in 0..columns {
                row.push(params.element_from_u64(column as u64));
            }
            data.push(row);
        }
        TraceSegment::new(name, (0..columns).map(|i| format!("c{i}")).collect(), data)
            .expect("valid segment")
    }

    #[test]
    fn column_conversion_preserves_lengths() {
        let segment = sample_segment("seg", 2, 3);
        let base_values = super::column_to_base_field(segment.rows.iter().map(|row| &row[0]));
        let secure_values = column_to_secure(segment.rows.iter().map(|row| &row[0]));
        assert_eq!(base_values.len(), 3);
        assert_eq!(secure_values.len(), 3);
    }

    #[cfg(feature = "backend-stwo")]
    #[test]
    fn segment_evaluations_pad_to_power_of_two() {
        use num_traits::Zero;

        let segment = sample_segment("seg", 1, 3);
        let descriptor = super::build_descriptor(&segment).expect("valid descriptor");
        let evaluations = super::segment_to_circle_evals(&segment, &descriptor);
        assert_eq!(evaluations.len(), 1);
        let evaluation = &evaluations[0];
        assert_eq!(evaluation.domain.size(), 1 << descriptor.log_size.max(1));
        assert_eq!(evaluation.values.len(), evaluation.domain.size());
        assert_eq!(
            evaluation.values[evaluation.values.len() - 1],
            BaseField::zero()
        );
    }

    #[cfg(feature = "backend-stwo")]
    #[test]
    fn component_handles_single_row_segments() {
        let params = StarkParameters::blueprint_default();
        let segment = sample_segment("single", 1, 1);
        let trace = ExecutionTrace::single(segment.clone()).expect("trace");
        let column = AirColumn::new(segment.name.clone(), segment.columns[0].clone());
        let constraint = AirConstraint::new(
            "single_row_zero",
            segment.name.clone(),
            ConstraintDomain::AllRows,
            AirExpression::from(column),
        );
        let air = AirDefinition::new(vec![constraint]);
        let component = BlueprintComponent::new(&air, &trace, &params).expect("component");

        let descriptor = &component.segments[0];
        let circle_evals = segment_to_circle_evals(&segment, descriptor);
        let circle_polys: Vec<_> = circle_evals
            .iter()
            .cloned()
            .map(|eval| eval.interpolate())
            .collect();
        let eval_refs: Vec<&CpuCircleEvaluation<BaseField, BitReversedOrder>> =
            circle_evals.iter().collect();
        let poly_refs: Vec<&CpuCirclePoly> = circle_polys.iter().collect();
        let trace_for_prover = Trace {
            polys: TreeVec(vec![Vec::new(), poly_refs]),
            evals: TreeVec(vec![Vec::new(), eval_refs]),
        };

        let mut accumulator = DomainEvaluationAccumulator::new(
            SecureField::from(3u32),
            component.max_constraint_log_degree_bound(),
            component.n_constraints(),
        );
        component.evaluate_constraint_quotients_on_domain(&trace_for_prover, &mut accumulator);

        let composition = accumulator.finalize();
        for poly in composition.0.iter() {
            assert!(poly.coeffs.iter().all(|coeff| *coeff == BaseField::zero()));
        }
    }

    #[test]
    fn ceil_log2_handles_small_inputs() {
        assert_eq!(ceil_log2(0), 0);
        assert_eq!(ceil_log2(1), 0);
        assert_eq!(ceil_log2(2), 1);
        assert_eq!(ceil_log2(3), 2);
        assert_eq!(ceil_log2(4), 2);
        assert_eq!(ceil_log2(5), 3);
    }

    #[test]
    fn descriptor_rejects_duplicate_columns() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.columns[1] = segment.columns[0].clone();
        let error = build_descriptor(&segment).expect_err("duplicate column");
        match error {
            AdapterError::DuplicateColumn { segment, column } => {
                assert_eq!(segment, "seg");
                assert_eq!(column, "c0");
            }
            _ => panic!("unexpected error: {error:?}"),
        }
    }

    #[test]
    fn descriptor_rejects_inconsistent_rows() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.rows[0].pop();
        let error = build_descriptor(&segment).expect_err("invalid row width");
        assert!(matches!(
            error,
            AdapterError::InconsistentRowWidth {
                segment: _,
                row_index: _,
                expected: _,
                actual: _
            }
        ));
    }

    #[test]
    fn component_detects_duplicate_segments() {
        let segment = sample_segment("seg", 2, 2);
        let trace =
            ExecutionTrace::from_segments(vec![segment.clone(), segment]).expect("valid trace");
        let params = StarkParameters::blueprint_default();
        let air = AirDefinition::new(vec![]);
        let error = BlueprintComponent::new(&air, &trace, &params).expect_err("duplicate segment");
        assert!(matches!(error, AdapterError::DuplicateSegment(_)));
    }
}
