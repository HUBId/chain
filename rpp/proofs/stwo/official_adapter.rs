//! Adapter between the blueprint-defined STWO objects and the official prover
//! interfaces.
#![allow(unexpected_cfgs)]
//!
//! The adapter owns references to the blueprint primitives (`AirDefinition`,
//! `ExecutionTrace`, and `StarkParameters`) while pre-computing fast lookup
//! tables for the execution trace segments. These descriptors are used by
//! subsequent trait implementations to bridge the lightweight blueprint models
//! with the official prover APIs.

use std::collections::HashMap;

use thiserror::Error;

use super::{
    air::AirDefinition,
    circuit::{ExecutionTrace, TraceSegment},
    conversions::{column_to_base, column_to_secure},
    params::{FieldElement, StarkParameters},
};
use stwo::stwo_official::core::fields::m31::BaseField;
use stwo::stwo_official::core::fields::qm31::SecureField;

/// Re-export key prover traits and types from the official STWO implementation
/// so that downstream modules can rely on them without repetitive imports.
pub use stwo::stwo_official::core::{ColumnVec, air::Component, pcs::TreeVec};

#[cfg(feature = "stwo/prover")]
use num_traits::Zero;
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::core::channel::MerkleChannel;
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::core::poly::circle::CanonicCoset;
/// Re-export prover-side structures when the upstream dependency exposes them.
#[cfg(feature = "stwo/prover")]
pub use stwo::stwo_official::prover::{
    air::component_prover::ComponentProver, backend::cpu::CpuBackend,
    poly::circle::CircleEvaluation,
};
#[cfg(feature = "stwo/prover")]
use stwo::stwo_official::prover::{
    backend::cpu::{CpuCircleEvaluation, CpuCirclePoly},
    pcs::CommitmentSchemeProver,
    poly::{BitReversedOrder, NaturalOrder},
};

/// Errors that can be raised while validating execution trace descriptors.
#[derive(Debug, Error)]
pub enum AdapterError {
    /// Raised when two trace segments share the same name.
    #[error("duplicate execution trace segment '{0}'")]
    DuplicateSegment(String),

    /// Raised when a segment declares the same column twice.
    #[error("segment '{segment}' defines duplicate column '{column}'")]
    DuplicateColumn { segment: String, column: String },

    /// Raised when a row has a different width than the declared column count.
    #[error("segment '{segment}' row {row_index} has width {actual}, expected {expected}")]
    InconsistentRowWidth {
        segment: String,
        row_index: usize,
        expected: usize,
        actual: usize,
    },
}

/// Metadata describing a single execution trace segment.
#[derive(Debug)]
pub struct SegmentDescriptor<'a> {
    /// Segment name as declared by the circuit witness.
    pub name: &'a str,
    /// Number of columns contained in the segment.
    pub column_count: usize,
    /// Number of rows contained in the segment.
    pub row_count: usize,
    /// Base-2 logarithm of the row count, rounded up.
    pub log_size: u32,
    /// Mapping between column names and their indices.
    pub column_indices: HashMap<&'a str, usize>,
}

/// Component description tying together the blueprint AIR, trace and
/// parameters with pre-computed segment descriptors.
#[derive(Debug)]
pub struct BlueprintComponent<'a> {
    /// AIR definition generated by the blueprint circuit implementation.
    pub air: &'a AirDefinition,
    /// Execution trace emitted by the blueprint circuit implementation.
    pub trace: &'a ExecutionTrace,
    /// STARK parameters bound to the circuit execution.
    pub parameters: &'a StarkParameters,
    /// Descriptor list for each execution trace segment.
    pub segments: Vec<SegmentDescriptor<'a>>,
    /// Quick lookup from segment name to descriptor index.
    pub segment_lookup: HashMap<&'a str, usize>,
}

impl<'a> BlueprintComponent<'a> {
    /// Create a new adapter component verifying trace metadata and computing
    /// descriptor tables used by the official prover integration.
    pub fn new(
        air: &'a AirDefinition,
        trace: &'a ExecutionTrace,
        parameters: &'a StarkParameters,
    ) -> Result<Self, AdapterError> {
        let mut segment_lookup = HashMap::new();
        let mut segments = Vec::with_capacity(trace.segments.len());

        for (segment_index, segment) in trace.segments.iter().enumerate() {
            register_segment(segment, segment_index, &mut segment_lookup)?;
            segments.push(build_descriptor(segment)?);
        }

        Ok(Self {
            air,
            trace,
            parameters,
            segments,
            segment_lookup,
        })
    }
}

fn column_to_base_field<'a, I>(column: I) -> Vec<BaseField>
where
    I: IntoIterator<Item = &'a FieldElement>,
{
    column_to_base(column)
}

fn column_to_secure_field<'a, I>(column: I) -> Vec<SecureField>
where
    I: IntoIterator<Item = &'a FieldElement>,
{
    column_to_secure(column)
}

fn register_segment<'a>(
    segment: &'a TraceSegment,
    index: usize,
    lookup: &mut HashMap<&'a str, usize>,
) -> Result<(), AdapterError> {
    let name = segment.name.as_str();
    if lookup.insert(name, index).is_some() {
        return Err(AdapterError::DuplicateSegment(segment.name.clone()));
    }
    Ok(())
}

fn build_descriptor<'a>(segment: &'a TraceSegment) -> Result<SegmentDescriptor<'a>, AdapterError> {
    let column_count = segment.columns.len();
    let mut column_indices = HashMap::with_capacity(column_count);
    for (column_index, column_name) in segment.columns.iter().enumerate() {
        let entry = column_indices.insert(column_name.as_str(), column_index);
        if entry.is_some() {
            return Err(AdapterError::DuplicateColumn {
                segment: segment.name.clone(),
                column: column_name.clone(),
            });
        }
    }

    for (row_index, row) in segment.rows.iter().enumerate() {
        if row.len() != column_count {
            return Err(AdapterError::InconsistentRowWidth {
                segment: segment.name.clone(),
                row_index,
                expected: column_count,
                actual: row.len(),
            });
        }
    }

    let row_count = segment.rows.len();
    let log_size = ceil_log2(row_count);

    Ok(SegmentDescriptor {
        name: segment.name.as_str(),
        column_count,
        row_count,
        log_size,
        column_indices,
    })
}

fn ceil_log2(value: usize) -> u32 {
    match value {
        0 | 1 => 0,
        _ => usize::BITS - (value - 1).leading_zeros(),
    }
}

#[cfg(feature = "stwo/prover")]
fn segment_to_circle_evals(
    segment: &TraceSegment,
    descriptor: &SegmentDescriptor<'_>,
) -> ColumnVec<CpuCircleEvaluation<BaseField, BitReversedOrder>> {
    let log_size = descriptor.log_size.max(1);
    let domain = CanonicCoset::new(log_size).circle_domain();
    let domain_size = domain.size();

    (0..descriptor.column_count)
        .map(|column_index| {
            let column_iter = segment.rows.iter().map(|row| &row[column_index]);
            let mut values = column_to_base_field(column_iter);
            values.resize(domain_size, BaseField::zero());
            CpuCircleEvaluation::<BaseField, NaturalOrder>::new(domain, values).bit_reverse()
        })
        .collect()
}

#[cfg(feature = "stwo/prover")]
#[derive(Debug)]
pub struct TraceCommitmentViews<'a> {
    pub polynomials: TreeVec<ColumnVec<&'a CpuCirclePoly>>,
    pub evaluations: TreeVec<ColumnVec<&'a CpuCircleEvaluation<BaseField, BitReversedOrder>>>,
}

#[cfg(feature = "stwo/prover")]
impl<'a> BlueprintComponent<'a> {
    pub fn build_commitment_views<'b, 'c, MC: MerkleChannel>(
        &self,
        commitment_scheme: &'b mut CommitmentSchemeProver<'c, CpuBackend, MC>,
        channel: &mut MC::C,
    ) -> TraceCommitmentViews<'b> {
        for (segment, descriptor) in self.trace.segments.iter().zip(&self.segments) {
            let evaluations = segment_to_circle_evals(segment, descriptor);
            let mut builder = commitment_scheme.tree_builder();
            builder.extend_evals(evaluations);
            builder.commit(channel);
        }

        let polynomials = prepend_preprocessed_tree(commitment_scheme.polynomials());
        let evaluations = prepend_preprocessed_tree(commitment_scheme.evaluations());

        TraceCommitmentViews {
            polynomials,
            evaluations,
        }
    }
}

#[cfg(feature = "stwo/prover")]
fn prepend_preprocessed_tree<T>(views: TreeVec<ColumnVec<T>>) -> TreeVec<ColumnVec<T>> {
    let mut trees = Vec::with_capacity(views.len() + 1);
    trees.push(Vec::new());
    trees.extend(views.0);
    TreeVec(trees)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stwo::circuit::TraceSegment;
    #[cfg(feature = "stwo/prover")]
    use stwo::stwo_official::core::fields::m31::BaseField;

    fn sample_segment(name: &str, columns: usize, rows: usize) -> TraceSegment {
        let params = StarkParameters::blueprint_default();
        let mut data = Vec::with_capacity(rows);
        for _ in 0..rows {
            let mut row = Vec::with_capacity(columns);
            for column in 0..columns {
                row.push(params.element_from_u64(column as u64));
            }
            data.push(row);
        }
        TraceSegment::new(name, (0..columns).map(|i| format!("c{i}")).collect(), data)
            .expect("valid segment")
    }

    #[test]
    fn column_conversion_preserves_lengths() {
        let segment = sample_segment("seg", 2, 3);
        let base_values = super::column_to_base_field(segment.rows.iter().map(|row| &row[0]));
        let secure_values = super::column_to_secure_field(segment.rows.iter().map(|row| &row[0]));
        assert_eq!(base_values.len(), 3);
        assert_eq!(secure_values.len(), 3);
    }

    #[cfg(feature = "stwo/prover")]
    #[test]
    fn segment_evaluations_pad_to_power_of_two() {
        use num_traits::Zero;

        let segment = sample_segment("seg", 1, 3);
        let descriptor = super::build_descriptor(&segment).expect("valid descriptor");
        let evaluations = super::segment_to_circle_evals(&segment, &descriptor);
        assert_eq!(evaluations.len(), 1);
        let evaluation = &evaluations[0];
        assert_eq!(evaluation.domain.size(), 1 << descriptor.log_size.max(1));
        assert_eq!(evaluation.values.len(), evaluation.domain.size());
        assert_eq!(
            evaluation.values[evaluation.values.len() - 1],
            BaseField::zero()
        );
    }

    #[test]
    fn ceil_log2_handles_small_inputs() {
        assert_eq!(ceil_log2(0), 0);
        assert_eq!(ceil_log2(1), 0);
        assert_eq!(ceil_log2(2), 1);
        assert_eq!(ceil_log2(3), 2);
        assert_eq!(ceil_log2(4), 2);
        assert_eq!(ceil_log2(5), 3);
    }

    #[test]
    fn descriptor_rejects_duplicate_columns() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.columns[1] = segment.columns[0].clone();
        let error = build_descriptor(&segment).expect_err("duplicate column");
        match error {
            AdapterError::DuplicateColumn { segment, column } => {
                assert_eq!(segment, "seg");
                assert_eq!(column, "c0");
            }
            _ => panic!("unexpected error: {error:?}"),
        }
    }

    #[test]
    fn descriptor_rejects_inconsistent_rows() {
        let mut segment = sample_segment("seg", 2, 4);
        segment.rows[0].pop();
        let error = build_descriptor(&segment).expect_err("invalid row width");
        assert!(matches!(
            error,
            AdapterError::InconsistentRowWidth {
                segment: _,
                row_index: _,
                expected: _,
                actual: _
            }
        ));
    }

    #[test]
    fn component_detects_duplicate_segments() {
        let segment = sample_segment("seg", 2, 2);
        let trace =
            ExecutionTrace::from_segments(vec![segment.clone(), segment]).expect("valid trace");
        let params = StarkParameters::blueprint_default();
        let air = AirDefinition::new(vec![]);
        let error = BlueprintComponent::new(&air, &trace, &params).expect_err("duplicate segment");
        assert!(matches!(error, AdapterError::DuplicateSegment(_)));
    }
}
