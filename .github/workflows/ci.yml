name: CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  plonky3-setup:
    name: Plonky3 setup reproducibility
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Regenerate Plonky3 setup artifacts
        run: |
          set -euo pipefail
          make plonky3-setup
      - name: Verify manifest digests
        run: |
          set -euo pipefail
          python3 - <<'PY'
import hashlib
import json
import sys
from pathlib import Path

root = Path('config/plonky3/setup')
manifest_path = root / 'manifest.json'
data = json.loads(manifest_path.read_text())

expected = {}
for entry in data.get('artifacts', []):
    expected[entry['file']] = entry['sha256']

missing = sorted(expected.keys())
actual = {}
for path in root.glob('*.json'):
    if path.name == 'manifest.json':
        continue
    actual[path.name] = hashlib.sha256(path.read_bytes()).hexdigest()

errors = False
for file, digest in sorted(actual.items()):
    recorded = expected.get(file)
    if recorded is None:
        print(f"::error file={file}::Missing manifest entry", file=sys.stderr)
        errors = True
        continue
    if recorded != digest:
        print(f"::error file={file}::Digest mismatch: expected {recorded}, found {digest}", file=sys.stderr)
        errors = True

unexpected = sorted(set(expected.keys()) - set(actual.keys()))
for file in unexpected:
    print(f"::error file={file}::Manifest entry has no matching artifact", file=sys.stderr)
    errors = True

if errors:
    sys.exit(1)
PY
      - name: Cross-check embedded hash manifests
        run: |
          set -euo pipefail
          python3 scripts/generate_plonky3_artifacts.py \
            config/plonky3/setup \
            --verify \
            --hash-output target/plonky3-setup-hashes.json
      - name: Ensure setup artifacts are committed
        run: |
          set -euo pipefail
          if ! git diff --quiet -- config/plonky3/setup; then
            git status --short config/plonky3/setup
            git diff config/plonky3/setup
            exit 1
          fi

  dashboards-json:
    name: Validate dashboard exports
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Validate Grafana JSON exports
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1
          files=(
            "dashboards/pipeline_overview.json"
            "dashboards/pipeline_wallet_intake.json"
            "dashboards/pipeline_proof_validation.json"
            "dashboards/pipeline_consensus_finality.json"
            "dashboards/pipeline_storage_commit.json"
            "dashboards/vrf_overview.json"
            "dashboards/vrf_thresholds.json"
            "dashboards/consensus_proof_validation.json"
            "observability/pipeline_grafana.json"
          )
          missing=0
          for file in "${files[@]}"; do
            path="docs/${file}"
            if [[ ! -f "${path}" ]]; then
              echo "::error file=${path}::Dashboard export is missing"
              missing=1
              continue
            fi
            jq empty "${path}"
          done
          python -m pip install --quiet 'pyyaml>=6'
          python - <<'PY'
import sys
from pathlib import Path

import yaml

files = [
    Path("docs/observability/alerts/root_integrity.yaml"),
    Path("docs/observability/alerts/consensus_vrf.yaml"),
    Path("docs/observability/alerts/snapshot_stream.yaml"),
]

error = False

for path in files:
    if not path.exists():
        print(f"::error file={path}::Alert definition is missing", file=sys.stderr)
        error = True
        continue

    try:
        data = yaml.safe_load(path.read_text())
    except yaml.YAMLError as exc:  # pragma: no cover - CI linting
        print(f"::error file={path}::Failed to parse YAML: {exc}", file=sys.stderr)
        error = True
        continue

    if not isinstance(data, dict):
        print(f"::error file={path}::Alert definition must be a mapping", file=sys.stderr)
        error = True
        continue

    for key in ("apiVersion", "kind", "metadata", "spec"):
        if key not in data:
            print(f"::error file={path}::Missing required top-level key '{key}'", file=sys.stderr)
            error = True

    spec = data.get("spec", {})
    groups = spec.get("groups") if isinstance(spec, dict) else None
    if not isinstance(groups, list) or not groups:
        print(f"::error file={path}::spec.groups must be a non-empty list", file=sys.stderr)
        error = True
        continue

    for group in groups:
        if not isinstance(group, dict):
            print(f"::error file={path}::Each group must be a mapping", file=sys.stderr)
            error = True
            continue
        rules = group.get("rules")
        if not isinstance(rules, list) or not rules:
            print(f"::error file={path}::Each group must define non-empty rules", file=sys.stderr)
            error = True
            continue
        for rule in rules:
            if not isinstance(rule, dict):
                print(f"::error file={path}::Each rule must be a mapping", file=sys.stderr)
                error = True
                continue
            for required in ("alert", "expr"):
                if required not in rule:
                    print(
                        f"::error file={path}::Rule missing required key '{required}'",
                        file=sys.stderr,
                    )
                    error = True

if error:
    sys.exit(1)
PY
          if [[ ${missing} -ne 0 ]]; then
            echo "One or more dashboard exports are missing."
            exit 1
          fi

  alerts-lint:
    name: Alert manifest lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install Spectral CLI
        run: npm install -g @stoplight/spectral-cli@6
      - name: Lint alert definitions
        run: |
          set -euo pipefail
          spectral lint docs/observability/alerts/*.yaml \
            -r docs/observability/alerts/.spectral.yaml

  runtime-smoke:
    name: Runtime smoke health checks
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Build runtime binary
        run: |
          set -euo pipefail
          cargo build --bin rpp-node
      - name: Exercise runtime modes
        env:
          RPP_NODE_BIN: "${{ github.workspace }}/target/debug/rpp-node"
          RPP_SUPPRESS_EXPERIMENTAL_BACKEND_WARNING: "1"
        run: |
          set -euo pipefail
          mkdir -p artifacts/runtime-smoke

          wait_for_endpoint() {
            local pid="$1"
            local url="$2"
            local timeout="$3"
            local elapsed=0

            while (( elapsed < timeout )); do
              if ! kill -0 "$pid" 2>/dev/null; then
                wait "$pid" || true
                return 1
              fi
              if curl --fail --silent --show-error --max-time 5 "$url" >/dev/null 2>&1; then
                return 0
              fi
              sleep 1
              elapsed=$((elapsed + 1))
            done

            echo "error: $url did not become healthy within ${timeout}s" >&2
            return 1
          }

          run_mode() {
            local mode="$1"
            local script="$2"
            local metrics_url="$3"
            shift 3
            local -a health_endpoints=("$@")
            local log_file="artifacts/runtime-smoke/${mode}.log"
            local metrics_file="artifacts/runtime-smoke/${mode}.metrics"
            local timeout=150

            echo "::group::runtime smoke (${mode})"

            local data_dir
            data_dir="$(mktemp -d)"

            (
              export RPP_NODE_DATA_DIR="${data_dir}"
              "${script}"
            ) >"${log_file}" 2>&1 &
            local runner_pid=$!

            cleanup() {
              if kill -0 "${runner_pid}" 2>/dev/null; then
                kill -TERM "${runner_pid}" 2>/dev/null || true
                wait "${runner_pid}" 2>/dev/null || true
              fi
              rm -rf "${data_dir}"
            }

            trap cleanup EXIT

            local endpoint
            for endpoint in "${health_endpoints[@]}"; do
              echo "probing ${endpoint}"
              if ! wait_for_endpoint "${runner_pid}" "${endpoint}" "${timeout}"; then
                echo "::error title=${mode} health check failed::${endpoint} did not report healthy" >&2
                trap - EXIT
                cleanup
                return 1
              fi
            done

            if ! curl --fail --silent --show-error --max-time 10 "${metrics_url}" >"${metrics_file}"; then
              echo "::error title=${mode} metrics scrape failed::Unable to fetch metrics from ${metrics_url}" >&2
              trap - EXIT
              cleanup
              return 1
            fi

            kill -TERM "${runner_pid}" 2>/dev/null || true
            if ! wait "${runner_pid}"; then
              local status=$?
              if [[ ${status} -ne 0 && ${status} -ne 143 ]]; then
                echo "::error title=${mode} runtime exit code::Process exited with status ${status}" >&2
                trap - EXIT
                cleanup
                return 1
              fi
            fi

            trap - EXIT
            cleanup
            echo "::endgroup::"
          }

          run_mode \
            node \
            "${GITHUB_WORKSPACE}/scripts/run_node_mode.sh" \
            "http://127.0.0.1:7070/metrics" \
            "http://127.0.0.1:7070/health/live" \
            "http://127.0.0.1:7070/health/ready"

          run_mode \
            wallet \
            "${GITHUB_WORKSPACE}/scripts/run_wallet_mode.sh" \
            "http://127.0.0.1:9090/metrics" \
            "http://127.0.0.1:9090/health/live" \
            "http://127.0.0.1:9090/health/ready"

          run_mode \
            hybrid \
            "${GITHUB_WORKSPACE}/scripts/run_hybrid_mode.sh" \
            "http://127.0.0.1:7070/metrics" \
            "http://127.0.0.1:7070/health/live" \
            "http://127.0.0.1:7070/health/ready"

      - name: Upload runtime smoke artifacts
        uses: actions/upload-artifact@v4
        with:
          name: runtime-smoke
          path: artifacts/runtime-smoke

  unit-suites:
    name: Unit suites (${{ matrix.name }})
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: default
            features: ""
            no_default_features: ""
            experimental: false
          - name: prod-stwo
            features: "prod,prover-stwo"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-plonky3
            features: "prod,prover-stwo,backend-plonky3"
            no_default_features: "1"
            experimental: false
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run unit validation suites
        run: |
          set -euo pipefail
          if [ -n "${{ matrix.no_default_features }}" ]; then
            export XTASK_NO_DEFAULT_FEATURES="${{ matrix.no_default_features }}"
          fi
          if [ -n "${{ matrix.features }}" ]; then
            export XTASK_FEATURES='${{ matrix.features }}'
          fi
          cargo xtask test-unit

  rpc-admission-audit:
    name: RPC admission audit guard
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run dual-approval audit guard
        run: |
          set -euo pipefail
          cargo test -p rpp-chain --locked --test admission

  worm-export-smoke:
    name: WORM export pipeline smoke test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Exercise WORM export stub pipeline
        run: |
          set -euo pipefail
          cargo xtask test-worm-export
      - name: Upload WORM smoke artifacts
        uses: actions/upload-artifact@v4
        with:
          name: worm-export-smoke
          path: target/worm-export-smoke

  snapshot-verifier:
    name: Snapshot verifier smoke test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Generate snapshot verifier bundle
        run: |
          set -euo pipefail
          cargo xtask snapshot-verifier
      - name: Upload snapshot verifier artifacts
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-verifier-smoke
          path: target/snapshot-verifier-smoke

  integration-workflows:
    name: Integration workflows (${{ matrix.name }})
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: default
            features: ""
            no_default_features: ""
            experimental: false
          - name: prod-stwo
            features: "prod,prover-stwo"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-plonky3
            features: "prod,prover-stwo,backend-plonky3"
            no_default_features: "1"
            experimental: false
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run integration workflows
        run: |
          set -euo pipefail
          if [ -n "${{ matrix.no_default_features }}" ]; then
            export XTASK_NO_DEFAULT_FEATURES="${{ matrix.no_default_features }}"
          fi
          if [ -n "${{ matrix.features }}" ]; then
            export XTASK_FEATURES='${{ matrix.features }}'
          fi
          cargo xtask test-integration

  observability-metrics:
    name: Observability metrics (${{ matrix.name }})
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: default
            features: ""
            no_default_features: ""
            experimental: false
          - name: prod-stwo
            features: "prod,prover-stwo"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-plonky3
            features: "prod,prover-stwo,backend-plonky3"
            no_default_features: "1"
            experimental: false
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run observability metrics
        run: |
          set -euo pipefail
          if [ -n "${{ matrix.no_default_features }}" ]; then
            export XTASK_NO_DEFAULT_FEATURES="${{ matrix.no_default_features }}"
          fi
          if [ -n "${{ matrix.features }}" ]; then
            export XTASK_FEATURES='${{ matrix.features }}'
          fi
          cargo xtask test-observability

  simnet-smoke:
    name: Simnet smoke (${{ matrix.name }})
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: default
            features: ""
            no_default_features: ""
            experimental: false
          - name: prod-stwo
            features: "prod,prover-stwo"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-plonky3
            features: "prod,prover-stwo,backend-plonky3"
            no_default_features: "1"
            experimental: false
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run simnet scenario
        run: |
          set -euo pipefail
          if [ -n "${{ matrix.no_default_features }}" ]; then
            export XTASK_NO_DEFAULT_FEATURES="${{ matrix.no_default_features }}"
          fi
          if [ -n "${{ matrix.features }}" ]; then
            export XTASK_FEATURES='${{ matrix.features }}'
          fi
          cargo xtask test-simnet

  simnet-regression:
    name: Simnet regression sweep
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run regression harness
        run: |
          set -euo pipefail
          rm -rf target/simnet/regression-ci
          cargo run -p simnet --bin regression -- \
            --artifacts-root target/simnet/regression-ci
      - name: Upload regression artifacts
        uses: actions/upload-artifact@v4
        with:
          name: simnet-regression
          path: target/simnet/regression-ci
