name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'SemVer tag to build (e.g. v1.2.3)'
        required: false

permissions:
  contents: write
  id-token: write
  actions: read

env:
  RUSTFLAGS: -D warnings
  CARGO_TERM_COLOR: always

jobs:
  checks:
    name: Lint, audit, and tests
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.determine_tag.outputs.release_tag }}
    steps:
      - name: Determine release tag
        id: determine_tag
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' && github.event.inputs.version || github.ref_name }}"
          if [[ -z "$tag" ]]; then
            echo "error: RELEASE_TAG is empty. Provide a SemVer tag via workflow dispatch or push a tag." >&2
            exit 1
          fi
          if [[ ! "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "error: '$tag' is not a valid SemVer tag" >&2
            exit 1
          fi
          echo "release_tag=$tag" >> "$GITHUB_OUTPUT"
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Enforce pinned nightly toolchain
        shell: bash
        run: |
          set -euo pipefail
          allowed="nightly-2025-07-14"
          repo_root="$(git rev-parse --show-toplevel)"
          cd "$repo_root"
          paths=("$repo_root" README.md Makefile prover scripts docs .github/workflows)
          mapfile -t pins < <(rg --no-heading -n -P 'nightly-\d{4}-\d{2}-\d{2}' --glob '!vendor/**' --glob '!**/vendor/**' "${paths[@]}" || true)
          status=0
          for match in "${pins[@]}"; do
            if [[ "$match" != *"$allowed"* ]]; then
              echo "error: unexpected nightly pin -> $match" >&2
              status=1
            fi
          done
          if rg --no-heading -n -P 'cargo \+nightly(?!-[0-9]{4}-[0-9]{2}-[0-9]{2})' --glob '!vendor/**' --glob '!**/vendor/**' "${paths[@]}"; then
            echo "error: found unpinned cargo + nightly invocation" >&2
            status=1
          fi
          if rg --no-heading -n -P 'rustup (toolchain )?install nightly(?!-[0-9]{4}-[0-9]{2}-[0-9]{2})' --glob '!vendor/**' --glob '!**/vendor/**' "${paths[@]}"; then
            echo "error: found unpinned rustup install of nightly" >&2
            status=1
          fi
          if [[ "$status" -ne 0 ]]; then
            exit "$status"
          fi
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt
      - name: Install pinned nightly toolchain
        run: rustup toolchain install nightly-2025-07-14 --profile minimal
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: release-checks
      - name: Format check
        run: cargo fmt --all -- --check
      - name: Clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings -D clippy::panic -D clippy::unwrap_used -D clippy::expect_used
      - name: Install test helpers
        run: |
          cargo install --locked cargo-audit
          cargo install --locked git-cliff
      - name: Cargo audit
        run: cargo audit --deny warnings
      - name: Verify snapshot integrity
        shell: bash
        run: |
          set -euo pipefail
          echo "Verifying snapshot integrity via root_corruption regression test"
          if ! cargo test --locked --test root_corruption; then
            echo "::error::Snapshot integrity regression detected. The root_corruption test failed." >&2
            exit 1
          fi
      - name: Test suite (default, STWO, RPP-Stark, and Plonky3 backends)
        run: ./scripts/test.sh --all --backend default --backend stwo --backend rpp-stark --backend plonky3
      - name: Guard against consensus manipulation regressions
        shell: bash
        run: |
          set -euo pipefail
          echo "Running consensus manipulation negative tests for STWO and Plonky3 backends"
          if ! cargo xtask test-consensus-manipulation; then
            echo "::error::Consensus manipulation negative tests failed. Ensure both STWO and Plonky3 backends reject manipulated VRF/quorum values." >&2
            exit 1
          fi
      - name: Prepare release notes
        run: ./scripts/prepare_changelog.sh --tag "${{ steps.determine_tag.outputs.release_tag }}" --output dist/release-notes.md
      - uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: dist/release-notes.md

  build-linux:
    name: Build Linux artifacts
    needs: checks
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            tool: cargo
          - target: aarch64-unknown-linux-gnu
            tool: cross
    runs-on: ubuntu-latest
    env:
      RELEASE_TAG: ${{ needs.checks.outputs.release_tag }}
      RPP_RELEASE_BASE_FEATURES: "--no-default-features --features prod,prover-stwo"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: release-${{ matrix.target }}
      - name: Install build tooling
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ matrix.tool }}" == "cross" ]]; then
            cargo install --locked cross
          fi
          cargo install --locked cargo-cyclonedx
      - name: Build ${{ matrix.target }}
        shell: bash
        env:
          SKIP_SNAPSHOT_INTEGRITY_TEST: 1
          SNAPSHOT_MANIFEST_PUBKEY_HEX: ${{ secrets.SNAPSHOT_MANIFEST_PUBKEY_HEX }}
        run: ./scripts/build_release.sh --target "${{ matrix.target }}" --profile release --out-dir dist/artifacts --tool "${{ matrix.tool }}"
      - name: Validate snapshot verifier report schema
        shell: bash
        run: |
          set -euo pipefail
          cargo xtask verify-report \
            --report "dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json"
      - name: Verify release feature set
        shell: bash
        run: ./scripts/verify_release_features.sh --target "${{ matrix.target }}" --profile release
      - name: Upload snapshot verifier report
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-verifier-${{ matrix.target }}
          path: |
            dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json
            dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json.sha256
      - uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.target }}
          path: dist/artifacts/${{ matrix.target }}

  build-macos:
    name: Build macOS artifacts
    needs: checks
    strategy:
      fail-fast: false
      matrix:
        target: [aarch64-apple-darwin, x86_64-apple-darwin]
    runs-on: macos-latest
    env:
      RELEASE_TAG: ${{ needs.checks.outputs.release_tag }}
      RPP_RELEASE_BASE_FEATURES: "--no-default-features --features prod,prover-stwo"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: release-${{ matrix.target }}
      - name: Install build tooling
        run: cargo install --locked cargo-cyclonedx
      - name: Build ${{ matrix.target }}
        shell: bash
        env:
          SKIP_SNAPSHOT_INTEGRITY_TEST: 1
          SNAPSHOT_MANIFEST_PUBKEY_HEX: ${{ secrets.SNAPSHOT_MANIFEST_PUBKEY_HEX }}
        run: ./scripts/build_release.sh --target "${{ matrix.target }}" --profile release --out-dir dist/artifacts --tool cargo
      - name: Validate snapshot verifier report schema
        shell: bash
        run: |
          set -euo pipefail
          cargo xtask verify-report \
            --report "dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json"
      - name: Verify release feature set
        shell: bash
        run: ./scripts/verify_release_features.sh --target "${{ matrix.target }}" --profile release
      - name: Upload snapshot verifier report
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-verifier-${{ matrix.target }}
          path: |
            dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json
            dist/artifacts/${{ matrix.target }}/snapshot-verify-report.json.sha256
      - uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.target }}
          path: dist/artifacts/${{ matrix.target }}

  publish:
    name: Sign and publish release
    needs:
      - checks
      - build-linux
      - build-macos
    runs-on: ubuntu-latest
    env:
      RELEASE_TAG: ${{ needs.checks.outputs.release_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: dist
      - uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: dist/artifacts
          merge-multiple: true
      - name: Generate Plonky3 hash manifest
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/generate_plonky3_artifacts.py \
            config/plonky3/setup \
            --verify \
            --hash-output dist/plonky3-setup-hashes.json
      - name: Remove per-target hash manifests
        shell: bash
        run: |
          set -euo pipefail
          find dist/artifacts -name 'plonky3-setup-hashes.json' -delete
      - uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.4.0'
      - name: Generate checksums
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t files < <(find dist/artifacts -type f \( -name '*.tar.gz' -o -name '*.json' \) -print | sort)
          if [[ ${#files[@]} -eq 0 ]]; then
            echo "error: no artifacts found to checksum" >&2
            exit 1
          fi
          if [[ -f dist/plonky3-setup-hashes.json ]]; then
            files+=("dist/plonky3-setup-hashes.json")
          fi
          ./scripts/checksums.sh --output dist/SHA256SUMS.txt "${files[@]}"
          ./scripts/verify_checksums.sh --manifest dist/SHA256SUMS.txt
      - name: Sign artifacts and checksums
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          mapfile -t files < <(find dist/artifacts -type f \( -name '*.tar.gz' -o -name '*.json' \) -print | sort)
          if [[ -f dist/plonky3-setup-hashes.json ]]; then
            files+=("dist/plonky3-setup-hashes.json")
          fi
          for file in "${files[@]}"; do
            cosign sign-blob --yes --output-signature "${file}.sig" --output-certificate "${file}.pem" "$file"
            target_dir="$(basename "$(dirname "$file")")"
            if [[ "$target_dir" == "dist" ]]; then
              target="plonky3-hashes"
            else
              target="$target_dir"
            fi
            subject="$(basename "$file")"
            ./scripts/provenance_attest.sh --artifact "$file" --target "$target" --subject "$subject"
          done
          cosign sign-blob --yes --output-signature dist/SHA256SUMS.txt.sig --output-certificate dist/SHA256SUMS.txt.pem dist/SHA256SUMS.txt
      - name: Prepare snapshot verifier release asset
        id: snapshot_asset
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t reports < <(find dist/artifacts -name 'snapshot-verify-report.json' -print | sort)
          if [[ ${#reports[@]} -eq 0 ]]; then
            echo "::error::snapshot-verify-report.json missing from release artifacts" >&2
            exit 1
          fi
          ref_report="${reports[0]}"
          ref_hash="$(sha256sum "$ref_report" | awk '{print $1}')"
          for report in "${reports[@]}"; do
            hash="$(sha256sum "$report" | awk '{print $1}')"
            if [[ "$hash" != "$ref_hash" ]]; then
              echo "::error::snapshot verifier reports differ across targets: $report" >&2
              exit 1
            fi
          done
          mkdir -p dist
          cp "$ref_report" dist/snapshot-verify-report.json
          echo "report_path=dist/snapshot-verify-report.json" >> "$GITHUB_OUTPUT"
          echo "sha256=$ref_hash" >> "$GITHUB_OUTPUT"
          has_signature=false
          signature_value=""
          if [[ -f "${ref_report}.sig" ]]; then
            cp "${ref_report}.sig" dist/snapshot-verify-report.json.sig
            echo "signature_path=dist/snapshot-verify-report.json.sig" >> "$GITHUB_OUTPUT"
            has_signature=true
            signature_value="$(tr -d '\n\r' < "${ref_report}.sig")"
          fi
          echo "signature_value=${signature_value}" >> "$GITHUB_OUTPUT"
          echo "has_signature=${has_signature}" >> "$GITHUB_OUTPUT"
      - name: Populate snapshot verifier hash/signature field
        shell: bash
        env:
          SNAPSHOT_SHA: ${{ steps.snapshot_asset.outputs.sha256 }}
          SNAPSHOT_SIG: ${{ steps.snapshot_asset.outputs.signature_value }}
        run: |
          set -euo pipefail
          if [[ -z "${SNAPSHOT_SHA}" ]]; then
            echo "::error::snapshot verifier hash missing from release asset preparation" >&2
            exit 1
          fi
          python3 - <<'PY'
import os
import pathlib
import sys

path = pathlib.Path("dist/release-notes.md")
if not path.exists():
    print("::error::release notes template missing", file=sys.stderr)
    sys.exit(1)

text = path.read_text()
sha = os.environ["SNAPSHOT_SHA"]
sig = os.environ.get("SNAPSHOT_SIG", "")
if not sig:
    sig = "n/a (kein Signatur-Asset verfÃ¼gbar)"

placeholders = {
    "SNAPSHOT_VERIFIER_SHA256_PLACEHOLDER": sha,
    "SNAPSHOT_VERIFIER_SIGNATURE_PLACEHOLDER": sig,
}

for marker, value in placeholders.items():
    if marker not in text:
        print(f"::error::placeholder {marker} missing from release notes", file=sys.stderr)
        sys.exit(1)
    text = text.replace(marker, value, 1)

path.write_text(text)
PY
      - name: Reference snapshot verifier reports in release notes
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t verifier_reports < <(find dist/artifacts -name 'snapshot-verify-report.json' -print | sort)
          if [[ ${#verifier_reports[@]} -eq 0 ]]; then
            echo "::error::snapshot-verify-report.json missing from release artifacts" >&2
            exit 1
          fi
          {
            printf '\n## Snapshot verifier attestation\n\n'
            printf 'Each build ships an aggregated `snapshot-verify` report plus the SHA256 digest produced during packaging. Validate the hash before consuming the report to ensure integrity.\n\n'
            for report in "${verifier_reports[@]}"; do
              sha_file="${report}.sha256"
              if [[ ! -f "$sha_file" ]]; then
                echo "::error::missing SHA256 sidecar for $report" >&2
                exit 1
              fi
              rel=${report#dist/artifacts/}
              hash=$(cut -d' ' -f1 "$sha_file")
              printf -- '- `%s` SHA256: `%s`\n' "$rel" "$hash"
            done
          } >> dist/release-notes.md
      - name: Reference snapshot summaries in release notes
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t summaries < <(find dist/artifacts -name 'snapshot-manifest-summary-*.json' -print | sort)
          if [[ ${#summaries[@]} -eq 0 ]]; then
            echo "No snapshot summaries detected; skipping release note update"
            exit 0
          fi
          {
            printf '\n## Snapshot bundle metadata\n\n'
            printf 'The release ships pruning snapshot metadata summaries alongside the bundle:\n\n'
            for summary in "${summaries[@]}"; do
              rel=${summary#dist/artifacts/}
              printf -- '- `%s`\n' "$rel"
            done
            cat <<'EOF'

Each JSON summary enumerates the manifest identifier, Firewood state root, and chunk count extracted from the persisted state-sync plan. Operators can validate the entries by recomputing `jq '.chunks | length'` against the corresponding `snapshot-<height>.json` plan and replaying the Light Client verification flow documented in the pruning operations runbook.
EOF
          } >> dist/release-notes.md
      - name: Publish GitHub release
        id: publish_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_TAG }}
          body_path: dist/release-notes.md
          files: |
            dist/SHA256SUMS.txt
            dist/SHA256SUMS.txt.sig
            dist/SHA256SUMS.txt.pem
            dist/plonky3-setup-hashes.json
            dist/plonky3-setup-hashes.json.sig
            dist/plonky3-setup-hashes.json.pem
            dist/plonky3-setup-hashes.json.intoto.jsonl
            dist/plonky3-setup-hashes.json.intoto.jsonl.sig
            dist/plonky3-setup-hashes.json.intoto.jsonl.pem
            dist/artifacts/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload snapshot verifier report asset
        if: steps.publish_release.outputs.upload_url != ''
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.publish_release.outputs.upload_url }}
          asset_path: ${{ steps.snapshot_asset.outputs.report_path }}
          asset_name: snapshot-verify-report.json
          asset_content_type: application/json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload snapshot verifier signature asset
        if: steps.snapshot_asset.outputs.has_signature == 'true' && steps.publish_release.outputs.upload_url != ''
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.publish_release.outputs.upload_url }}
          asset_path: ${{ steps.snapshot_asset.outputs.signature_path }}
          asset_name: snapshot-verify-report.json.sig
          asset_content_type: application/octet-stream
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
