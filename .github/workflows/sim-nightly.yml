name: sim-nightly

on:
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:

jobs:
  nightly-sim:
    runs-on: ubuntu-latest
    env:
      RPP_SIM_STATIC_KEY_SEED: nightly-smoke
      RPP_SIM_REQUIRE_DETERMINISTIC: "0"
      CARGO_TERM_COLOR: always
      RUSTFLAGS: -D warnings
      CARGO_HOME: ${{ github.workspace }}/.cargo
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.79.0
          components: rustfmt, clippy
      - name: Audit deterministic cargo environment
        run: |
          expected="$GITHUB_WORKSPACE/.cargo"
          if [ "${CARGO_HOME}" != "$expected" ]; then
            echo "CARGO_HOME mismatch: ${CARGO_HOME} != $expected" >&2
            exit 1
          fi
          if [ "${RUSTFLAGS:-}" != "-D warnings" ]; then
            echo "RUSTFLAGS mismatch: ${RUSTFLAGS:-<unset>}" >&2
            exit 1
          fi
          mkdir -p "$CARGO_HOME"
      - name: Cache cargo directories
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.CARGO_HOME }}/registry
            ${{ env.CARGO_HOME }}/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
      - name: Run ignored rpp-sim smoke tests
        run: |
          cargo test -p rpp-sim -- --ignored
      - name: Generate nightly simulation summaries
        run: |
          cargo run -p rpp-sim -- --scenario scenarios/small_world_smoke.toml --output target/sim-smoke/nightly-summary.json
          cargo run -p rpp-sim -- --scenario scenarios/partition_restart_plan.toml --output target/sim-smoke/nightly-partition-summary.json
      - name: Enforce partition restart plan thresholds
        run: |
          python - <<'PY'
import json
import sys

PLAN_MAX_REJOIN_LATENCY_MS = 12_000.0
PLAN_MIN_MESH_STABILITY = 0.82

summary_path = "target/sim-smoke/nightly-partition-summary.json"
with open(summary_path) as handle:
    summary = json.load(handle)

if not any(fault["kind"] == "partition_start" for fault in summary.get("faults", [])):
    sys.exit("missing partition_start fault event")
if not any(fault["kind"] == "partition_end" for fault in summary.get("faults", [])):
    sys.exit("missing partition_end fault event")

down_events = {}
max_rejoin = 0.0
down_count = 0
up_count = 0

for fault in summary.get("faults", []):
    kind = fault["kind"]
    detail = fault.get("detail")
    timestamp = fault["timestamp_ms"]
    if kind == "churn_down":
        if detail is None:
            sys.exit("churn_down event missing node detail")
        down_events[detail] = timestamp
        down_count += 1
    elif kind == "churn_up":
        if detail is None:
            sys.exit("churn_up event missing node detail")
        if detail not in down_events:
            sys.exit(f"no matching churn_down for {detail}")
        latency = timestamp - down_events.pop(detail)
        if latency > max_rejoin:
            max_rejoin = latency
        up_count += 1

if down_count != up_count:
    sys.exit(f"mismatched churn events: down={down_count} up={up_count}")
if down_events:
    sys.exit(f"outstanding churn_down events without recovery: {sorted(down_events)}")

if max_rejoin > PLAN_MAX_REJOIN_LATENCY_MS:
    sys.exit(
        f"max rejoin latency {max_rejoin:.2f} ms exceeds plan target {PLAN_MAX_REJOIN_LATENCY_MS:.2f} ms"
    )

total_receives = max(summary.get("total_receives", 0), 1)
mesh_changes = float(len(summary.get("mesh_changes", [])))
mesh_stability = 1.0 - mesh_changes / float(total_receives)

if mesh_stability < PLAN_MIN_MESH_STABILITY:
    sys.exit(
        f"mesh stability {mesh_stability:.3f} below plan floor {PLAN_MIN_MESH_STABILITY:.3f}"
    )

print(
    "partition restart plan thresholds satisfied: max_rejoin={:.2f}ms mesh_stability={:.3f}".format(
        max_rejoin, mesh_stability
    )
)
PY
