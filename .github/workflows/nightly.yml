name: nightly-simnet

on:
  schedule:
    # Mondays at 01:30 UTC
    - cron: '30 1 * * 1'
  workflow_dispatch:

jobs:
  worm-export:
    name: WORM export stub verification
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Run WORM export smoke test
        env:
          WORM_EXPORT_STUB_ENDPOINT: http://127.0.0.1:9700
        run: |
          set -euo pipefail
          cargo run -p worm-export-stub -- --listen 127.0.0.1:9700 --storage target/worm-export-stub-server &
          stub_pid=$!
          trap 'kill "$stub_pid"' EXIT
          ready=0
          for attempt in $(seq 1 30); do
            if curl -fsS http://127.0.0.1:9700/healthz >/dev/null; then
              ready=1
              break
            fi
            sleep 1
          done
          if [ "$ready" -ne 1 ]; then
            echo "::error::WORM export stub failed to start" >&2
            exit 1
          fi
          cargo xtask test-worm-export
          cargo test --test compliance --features integration -- worm_export_failure_emits_metric_and_log
      - name: Verify WORM retention windows
        env:
          OBSERVABILITY_METRICS_OTLP_ENDPOINT: ${{ secrets.OBSERVABILITY_METRICS_OTLP_ENDPOINT }}
          OBSERVABILITY_METRICS_AUTH_TOKEN: ${{ secrets.OBSERVABILITY_METRICS_AUTH_TOKEN }}
          OBSERVABILITY_METRICS_HEADERS: ${{ secrets.OBSERVABILITY_METRICS_HEADERS }}
          OBSERVABILITY_METRICS_PROM_PATH: target/metrics/worm_retention.prom
          OBSERVABILITY_METRICS_SERVICE_NAME: compliance-nightly
          OBSERVABILITY_METRICS_SERVICE_INSTANCE: nightly-${{ github.run_id }}
          OBSERVABILITY_METRICS_SCOPE: nightly.worm_retention
          OBSERVABILITY_METRICS_JOB: worm-retention
        run: |
          set -euo pipefail
          cargo xtask worm-retention-check
      - name: Upload WORM retention report
        uses: actions/upload-artifact@v4
        with:
          name: worm-retention-report.json
          path: target/compliance/worm-retention/worm-retention-report.json
      - name: Upload WORM export smoke artifacts
        uses: actions/upload-artifact@v4
        with:
          name: worm-export-smoke
          path: target/worm-export-smoke

  alert-validation:
    name: Alert validation drill
    runs-on: ubuntu-latest
    needs:
      - worm-export
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install alert validation dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install -r tools/alerts/requirements.txt

      - name: Run alert validation drills
        run: |
          set -euo pipefail
          python tools/alerts/validate_alerts.py
          python -m pytest tools/alerts/tests

  telemetry-chaos:
    name: Telemetry exporter chaos drill
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Run OTLP exporter chaos test
        run: |
          set -euo pipefail
          cargo test --test observability_otlp_failures --features integration

      - name: Upload telemetry chaos artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: telemetry-chaos
          path: rpp/chain/artifacts/telemetry-chaos

  storage-chaos:
    name: Firewood WAL crash chaos drill
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Run Firewood WAL crash recovery test
        run: |
          set -euo pipefail
          cargo test --test storage -- --ignored wal_crash_recovery_handles_abrupt_termination

      - name: Upload Firewood WAL chaos artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: firewood-wal-chaos
          path: target/compliance/chaos/firewood-wal

  mempool-status-probe:
    name: Mempool status probe
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Exercise /status/mempool alert probe
        run: |
          set -euo pipefail
          cargo test -p rpp-chain --test mempool -- mempool_status_probe_flags_queue_saturation_alerts

  replay-guard-probe:
    name: Replay guard alert probe
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Exercise replay guard saturation alerts
        run: |
          set -euo pipefail
          cargo test -p rpp-chain --test networking -- replay_alert_probe_saturates_window_triggers_alerts

  zk-alert-probes:
    name: ZK backend alert probes
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Validate zk alert definitions
        run: |
          set -euo pipefail
          ruby scripts/ci/validate_prometheus_rules.rb ops/alerts/zk

      - name: Exercise zk alert probes
        run: |
          set -euo pipefail
          cargo test -p rpp-chain --test zk_alert_probe

  verify-smoke-artifacts:
    name: Verify CI smoke artifacts
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TARGET_BRANCH: ${{ github.ref_name }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
      REPOSITORY: ${{ github.repository }}
    steps:
      - name: Ensure snapshot-verifier and worm-export smoke artifacts exist
        run: |
          set -euo pipefail

          branch="${TARGET_BRANCH:-}"
          if [[ -z "$branch" || "$branch" == "HEAD" ]]; then
            branch="${DEFAULT_BRANCH:-main}"
          fi

          workflow_path="ci.yml"
          runs_json=$(gh api \
            "/repos/${REPOSITORY}/actions/workflows/${workflow_path}/runs" \
            -f branch="$branch" \
            -f status=success \
            -F per_page=1)
          run_id=$(jq -r '.workflow_runs[0].id // empty' <<<"$runs_json")
          if [[ -z "$run_id" ]]; then
            echo "::error::Kein erfolgreicher ci.yml-Lauf für Branch '$branch' gefunden" >&2
            exit 1
          fi

          run_url="https://github.com/${REPOSITORY}/actions/runs/${run_id}"
          artifacts_json=$(gh api \
            "/repos/${REPOSITORY}/actions/runs/${run_id}/artifacts" \
            -F per_page=100)

          has_snapshot=$(jq '[.artifacts[] | select(.name=="snapshot-verifier-smoke" and (.expired != true))] | length' <<<"$artifacts_json")
          has_worm=$(jq '[.artifacts[] | select(.name=="worm-export-smoke" and (.expired != true))] | length' <<<"$artifacts_json")

          missing=()
          if [[ "${has_snapshot}" -eq 0 ]]; then
            missing+=("snapshot-verifier-smoke (Job snapshot-verifier)")
          fi
          if [[ "${has_worm}" -eq 0 ]]; then
            missing+=("worm-export-smoke (Job worm-export-smoke)")
          fi

          if [[ ${#missing[@]} -ne 0 ]]; then
            printf '::error::Fehlende CI-Artefakte im Lauf %s: %s\n' "$run_url" "${missing[*]}" >&2
            exit 1
          fi

          echo "Alle erwarteten Artefakte aus ci.yml vorhanden (Run ${run_url})."

  timetoke-slo-report:
    name: Timetoke replay SLO report
    runs-on: ubuntu-latest
    env:
      TIMETOKE_PROMETHEUS_URL: ${{ secrets.TIMETOKE_PROMETHEUS_URL }}
      TIMETOKE_PROMETHEUS_BEARER: ${{ secrets.TIMETOKE_PROMETHEUS_BEARER }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Generate Timetoke SLO report
        run: |
          set -euo pipefail
          if [ -n "${TIMETOKE_PROMETHEUS_URL:-}" ]; then
            cargo xtask report-timetoke-slo \
              --prometheus-url "${TIMETOKE_PROMETHEUS_URL}" \
              --output timetoke-slo-report.md
          else
            cargo xtask report-timetoke-slo \
              --metrics-log docs/observability/examples/timetoke_metrics.jsonl \
              --output timetoke-slo-report.md
          fi

      - name: Upload SLO report
        uses: actions/upload-artifact@v4
        with:
          name: timetoke-slo-report
          path: timetoke-slo-report.md

  snapshot-health:
    name: Snapshot stream health audit
    if: ${{ secrets.SNAPSHOT_RPC_URL != '' }}
    runs-on: ubuntu-latest
    env:
      SNAPSHOT_RPC_URL: ${{ secrets.SNAPSHOT_RPC_URL }}
      SNAPSHOT_RPC_TOKEN: ${{ secrets.SNAPSHOT_RPC_TOKEN }}
      SNAPSHOT_MANIFEST_PATH: ${{ secrets.SNAPSHOT_MANIFEST_PATH }}
      SNAPSHOT_MANIFEST_JSON: ${{ secrets.SNAPSHOT_MANIFEST_JSON }}
      SNAPSHOT_VALIDATOR_CONFIG: ${{ secrets.SNAPSHOT_VALIDATOR_CONFIG }}
      SNAPSHOT_MANIFEST_PUBKEY_HEX: ${{ secrets.SNAPSHOT_MANIFEST_PUBKEY_HEX }}
      SNAPSHOT_CHUNK_ROOT: ${{ secrets.SNAPSHOT_CHUNK_ROOT }}
      SNAPSHOT_CHUNK_ARCHIVE_URL: ${{ secrets.SNAPSHOT_CHUNK_ARCHIVE_URL }}
      SNAPSHOT_CHUNK_ROOT_SUBDIR: ${{ secrets.SNAPSHOT_CHUNK_ROOT_SUBDIR }}
      SNAPSHOT_MANIFEST_SIGNATURE_PATH: ${{ secrets.SNAPSHOT_MANIFEST_SIGNATURE_PATH }}
      SNAPSHOT_MANIFEST_SIGNATURE: ${{ secrets.SNAPSHOT_MANIFEST_SIGNATURE }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Build rpp-node CLI
        run: |
          set -euo pipefail
          cargo build -p rpp-node --release

      - name: Audit snapshot sessions
        run: |
          set -euo pipefail
          CONFIG_PATH="${SNAPSHOT_VALIDATOR_CONFIG:-config/validator.toml}"
          cargo xtask snapshot-health \
            --config "${CONFIG_PATH}" \
            --output snapshot-health-report.json \
            --rpp-node-bin target/release/rpp-node
      - name: Stage snapshot chunks
        if: ${{ env.SNAPSHOT_MANIFEST_PUBKEY_HEX != '' && (env.SNAPSHOT_MANIFEST_PATH != '' || env.SNAPSHOT_MANIFEST_JSON != '') && (env.SNAPSHOT_CHUNK_ROOT != '' || env.SNAPSHOT_CHUNK_ARCHIVE_URL != '') }}
        id: stage_chunks
        run: |
          set -euo pipefail
          if [[ -n "${SNAPSHOT_CHUNK_ROOT:-}" && -d "${SNAPSHOT_CHUNK_ROOT}" ]]; then
            chunk_root="$SNAPSHOT_CHUNK_ROOT"
          elif [[ -n "${SNAPSHOT_CHUNK_ARCHIVE_URL:-}" ]]; then
            workdir="$(mktemp -d)"
            archive="$workdir/archive"
            echo "Downloading snapshot chunks from $SNAPSHOT_CHUNK_ARCHIVE_URL"
            curl -fsSL "$SNAPSHOT_CHUNK_ARCHIVE_URL" -o "$archive"
            extract_dir="$workdir/extracted"
            mkdir "$extract_dir"
            case "$SNAPSHOT_CHUNK_ARCHIVE_URL" in
              *.tar.gz|*.tgz)
                tar -xzf "$archive" -C "$extract_dir"
                ;;
              *.tar)
                tar -xf "$archive" -C "$extract_dir"
                ;;
              *.zip)
                unzip -q "$archive" -d "$extract_dir"
                ;;
              *)
                echo "::error::Unsupported archive format: $SNAPSHOT_CHUNK_ARCHIVE_URL" >&2
                exit 1
                ;;
            esac
            mapfile -t entries < <(find "$extract_dir" -mindepth 1 -maxdepth 1 -type d | sort)
            if [[ -n "${SNAPSHOT_CHUNK_ROOT_SUBDIR:-}" ]]; then
              chunk_root="$extract_dir/$SNAPSHOT_CHUNK_ROOT_SUBDIR"
            elif [[ ${#entries[@]} -eq 1 ]]; then
              chunk_root="${entries[0]}"
            else
              chunk_root="$extract_dir"
            fi
            echo "Snapshot chunks extracted to $chunk_root"
          else
            echo "::error::SNAPSHOT_CHUNK_ROOT is not present and SNAPSHOT_CHUNK_ARCHIVE_URL is unset" >&2
            exit 1
          fi
          if [[ ! -d "$chunk_root" ]]; then
            echo "::error::Chunk root $chunk_root does not exist or is not a directory" >&2
            exit 1
          fi
          echo "SNAPSHOT_CHUNK_ROOT=$chunk_root" >>"$GITHUB_ENV"
          echo "chunk_root=$chunk_root" >>"$GITHUB_OUTPUT"
      - name: Verify snapshot manifest signature
        if: ${{ env.SNAPSHOT_MANIFEST_PUBKEY_HEX != '' && (env.SNAPSHOT_CHUNK_ROOT != '' || env.SNAPSHOT_CHUNK_ARCHIVE_URL != '') && (env.SNAPSHOT_MANIFEST_PATH != '' || env.SNAPSHOT_MANIFEST_JSON != '') }}
        run: |
          set -euo pipefail
          key_path="$(mktemp)"
          printf '%s' "$SNAPSHOT_MANIFEST_PUBKEY_HEX" >"$key_path"
          manifest_payload="${SNAPSHOT_MANIFEST_JSON:-}"
          manifest_path="${SNAPSHOT_MANIFEST_PATH:-}"
          cleanup_manifest=0
          if [[ -n "$manifest_payload" ]]; then
            manifest_path="$(mktemp)"
            printf '%s' "$manifest_payload" >"$manifest_path"
            cleanup_manifest=1
            if [[ -n "${SNAPSHOT_MANIFEST_SIGNATURE:-}" ]]; then
              printf '%s' "$SNAPSHOT_MANIFEST_SIGNATURE" >"${manifest_path}.sig"
            fi
          fi
          if [[ -z "$manifest_path" ]]; then
            echo "::error::No snapshot manifest payload provided" >&2
            exit 1
          fi
          if [[ ! -f "$manifest_path" ]]; then
            echo "::error::Snapshot manifest $manifest_path is not accessible" >&2
            exit 1
          fi
          signature_path="${SNAPSHOT_MANIFEST_SIGNATURE_PATH:-${manifest_path}.sig}"
          if [[ ! -f "$signature_path" ]]; then
            echo "::error::Snapshot manifest signature not found at $signature_path" >&2
            exit 1
          fi
          report_path="snapshot-manifest-verify.json"
          cargo run --locked --package snapshot-verify -- \
            --manifest "$manifest_path" \
            --signature "$signature_path" \
            --public-key "$key_path" \
            --chunk-root "$SNAPSHOT_CHUNK_ROOT" \
            --output "$report_path"
          rm -f "$key_path"
          if [[ $cleanup_manifest -eq 1 ]]; then
            rm -f "$manifest_path" "${manifest_path}.sig"
          fi

      - name: Validate snapshot verifier report schema
        if: ${{ env.SNAPSHOT_MANIFEST_PUBKEY_HEX != '' && (env.SNAPSHOT_CHUNK_ROOT != '' || env.SNAPSHOT_CHUNK_ARCHIVE_URL != '') && (env.SNAPSHOT_MANIFEST_PATH != '' || env.SNAPSHOT_MANIFEST_JSON != '') }}
        run: |
          set -euo pipefail
          cargo xtask verify-report --report snapshot-manifest-verify.json

      - name: Upload snapshot health report
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-health-report
          path: snapshot-health-report.json

      - name: Upload snapshot manifest verification report
        if: ${{ env.SNAPSHOT_MANIFEST_PUBKEY_HEX != '' && (env.SNAPSHOT_CHUNK_ROOT != '' || env.SNAPSHOT_CHUNK_ARCHIVE_URL != '') && (env.SNAPSHOT_MANIFEST_PATH != '' || env.SNAPSHOT_MANIFEST_JSON != '') }}
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-manifest-verify
          path: snapshot-manifest-verify.json

  staging-soak:
    name: Staging soak orchestration
    runs-on: ubuntu-latest
    env:
      SNAPSHOT_RPC_URL: ${{ secrets.SNAPSHOT_RPC_URL }}
      SNAPSHOT_RPC_TOKEN: ${{ secrets.SNAPSHOT_RPC_TOKEN }}
      SNAPSHOT_VALIDATOR_CONFIG: ${{ secrets.SNAPSHOT_VALIDATOR_CONFIG }}
      SNAPSHOT_MANIFEST_PATH: ${{ secrets.SNAPSHOT_MANIFEST_PATH }}
      SNAPSHOT_MANIFEST_JSON: ${{ secrets.SNAPSHOT_MANIFEST_JSON }}
      SNAPSHOT_MANIFEST_PUBKEY_HEX: ${{ secrets.SNAPSHOT_MANIFEST_PUBKEY_HEX }}
      SNAPSHOT_CHUNK_ROOT: ${{ secrets.SNAPSHOT_CHUNK_ROOT }}
      SNAPSHOT_CHUNK_ARCHIVE_URL: ${{ secrets.SNAPSHOT_CHUNK_ARCHIVE_URL }}
      SNAPSHOT_CHUNK_ROOT_SUBDIR: ${{ secrets.SNAPSHOT_CHUNK_ROOT_SUBDIR }}
      SNAPSHOT_MANIFEST_SIGNATURE_PATH: ${{ secrets.SNAPSHOT_MANIFEST_SIGNATURE_PATH }}
      SNAPSHOT_MANIFEST_SIGNATURE: ${{ secrets.SNAPSHOT_MANIFEST_SIGNATURE }}
      TIMETOKE_PROMETHEUS_URL: ${{ secrets.TIMETOKE_PROMETHEUS_URL }}
      TIMETOKE_PROMETHEUS_BEARER: ${{ secrets.TIMETOKE_PROMETHEUS_BEARER }}
      ADMISSION_RPC_URL: ${{ secrets.ADMISSION_RPC_URL }}
      ADMISSION_RPC_TOKEN: ${{ secrets.ADMISSION_RPC_TOKEN }}
      ADMISSION_POLICY_PATH: ${{ secrets.ADMISSION_POLICY_PATH }}
      ADMISSION_MAX_AUDIT_LAG_SECS: ${{ secrets.ADMISSION_MAX_AUDIT_LAG_SECS }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Run staging soak orchestrator
        id: soak
        run: |
          set -euo pipefail
          mkdir -p nightly-artifacts/staging-soak
          set +e
          cargo xtask staging-soak --output-dir nightly-artifacts/staging-soak
          status=$?
          set -e
          summary_path=$(find nightly-artifacts/staging-soak -name summary.json -print | sort | tail -n 1)
          if [[ -n "$summary_path" ]]; then
            echo "summary_path=$summary_path" >>"$GITHUB_OUTPUT"
          fi
          echo "exit_status=$status" >>"$GITHUB_OUTPUT"

      - name: Upload staging soak artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: staging-soak
          path: nightly-artifacts/staging-soak
          if-no-files-found: warn

      - name: Evaluate staging soak summary
        id: evaluate
        run: |
          set -euo pipefail
          summary="${{ steps.soak.outputs.summary_path }}"
          if [[ -z "$summary" || ! -f "$summary" ]]; then
            echo "summary_path=$summary" >>"$GITHUB_OUTPUT"
            echo "summary_missing=true" >>"$GITHUB_OUTPUT"
            echo "overall_ok=false" >>"$GITHUB_OUTPUT"
            echo "snapshot_ok=false" >>"$GITHUB_OUTPUT"
            echo "timetoke_ok=false" >>"$GITHUB_OUTPUT"
            echo "admission_ok=false" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          snapshot_ok=$(jq -r '.snapshot.ok' "$summary")
          timetoke_ok=$(jq -r '.timetoke.ok' "$summary")
          admission_ok=$(jq -r '.admission.ok' "$summary")
          overall=$(jq -r '.ok' "$summary")
          echo "summary_path=$summary" >>"$GITHUB_OUTPUT"
          echo "summary_missing=false" >>"$GITHUB_OUTPUT"
          echo "snapshot_ok=$snapshot_ok" >>"$GITHUB_OUTPUT"
          echo "timetoke_ok=$timetoke_ok" >>"$GITHUB_OUTPUT"
          echo "admission_ok=$admission_ok" >>"$GITHUB_OUTPUT"
          echo "overall_ok=$overall" >>"$GITHUB_OUTPUT"

      - name: Verify staging soak SLO thresholds
        id: verify_slo
        env:
          SUMMARY_PATH: ${{ steps.evaluate.outputs.summary_path }}
          REPORT_OUTPUT: nightly-artifacts/staging_soak_report.json
          SNAPSHOT_SLO_REFERENCE: docs/observability/pipeline.md#dashboard-blueprint
          TIMETOKE_SLO_REFERENCE: docs/observability/timetoke.md#slo-thresholds
        run: |
          set -euo pipefail
          summary_path="${SUMMARY_PATH:-}"
          report_output="${REPORT_OUTPUT}"
          if [[ -z "$summary_path" || ! -f "$summary_path" ]]; then
            {
              echo "report_path="
              echo "slo_ok=false"
              echo "failure_reason=Staging-Soak-Summary fehlt (erwartet nightly-artifacts/staging-soak/<datum>/<timestamp>/summary.json)."
            } >>"$GITHUB_OUTPUT"
            exit 0
          fi
          mkdir -p "$(dirname "$report_output")"
          python3 <<'PY'
import json
import os

summary_path = os.environ["SUMMARY_PATH"]
report_output = os.environ["REPORT_OUTPUT"]
snapshot_ref = os.environ.get("SNAPSHOT_SLO_REFERENCE", "docs/observability/pipeline.md")
timetoke_ref = os.environ.get("TIMETOKE_SLO_REFERENCE", "docs/observability/timetoke.md")

with open(summary_path, "r", encoding="utf-8") as fh:
    summary = json.load(fh)

errors = []

snapshot = summary.get("snapshot") or {}
unhealthy = snapshot.get("unhealthy_sessions")
total_sessions = snapshot.get("total_sessions")
if unhealthy is None:
    errors.append(
        "Snapshot-Report enthält kein Feld 'snapshot.unhealthy_sessions' (siehe %s)." % snapshot_ref
    )
elif isinstance(unhealthy, (int, float)) and unhealthy > 0:
    total_text = str(total_sessions) if total_sessions is not None else "unbekannt"
    errors.append(
        f"Snapshot-SLO verletzt: {unhealthy} von {total_text} Sessions melden Anomalien (Ziel: 0 laut {snapshot_ref})."
    )

timetoke = summary.get("timetoke") or {}
success_rate = timetoke.get("success_rate")
target_rate = timetoke.get("success_rate_target")
if success_rate is None or target_rate is None:
    errors.append(
        "Timetoke-Report enthält keine Erfolgsquote oder Zielschwelle (siehe %s)." % timetoke_ref
    )
elif success_rate < target_rate:
    errors.append(
        f"Timetoke-Erfolgsquote {success_rate:.4%} unterschreitet das SLO {target_rate:.2%} ({timetoke_ref})."
    )

latency_targets = timetoke.get("latency_targets_ms") or {}
for field, label, target_key in [
    ("latency_p50_ms", "p50", "p50_ms"),
    ("latency_p95_ms", "p95", "p95_ms"),
    ("latency_p99_ms", "p99", "p99_ms"),
]:
    value = timetoke.get(field)
    target_value = latency_targets.get(target_key)
    if value is None or target_value is None:
        errors.append(
            f"Timetoke-Latenzfeld '{field}' oder Ziel '{target_key}' fehlt ({timetoke_ref})."
        )
        continue
    if value > target_value:
        errors.append(
            f"Timetoke-Latenz {label} = {value:.0f} ms überschreitet das SLO {target_value:.0f} ms ({timetoke_ref})."
        )

report = {
    "generated_at": summary.get("generated_at"),
    "run_directory": summary.get("run_directory"),
    "snapshot": {
        "report_path": snapshot.get("report_path"),
        "total_sessions": total_sessions,
        "unhealthy_sessions": unhealthy,
        "slo": {
            "max_unhealthy_sessions": 0,
            "reference": snapshot_ref,
        },
    },
    "timetoke": {
        "report_path": timetoke.get("report_path"),
        "source": timetoke.get("source"),
        "successes": timetoke.get("successes"),
        "failures": timetoke.get("failures"),
        "success_rate": success_rate,
        "success_rate_target": target_rate,
        "latency_p50_ms": timetoke.get("latency_p50_ms"),
        "latency_p95_ms": timetoke.get("latency_p95_ms"),
        "latency_p99_ms": timetoke.get("latency_p99_ms"),
        "latency_targets_ms": latency_targets,
        "slo_reference": timetoke_ref,
    },
}

with open(report_output, "w", encoding="utf-8") as fh:
    json.dump(report, fh, indent=2, ensure_ascii=False)

gh_output = os.environ["GITHUB_OUTPUT"]
with open(gh_output, "a", encoding="utf-8") as fh:
    fh.write(f"report_path={report_output}\n")
    fh.write(f"slo_ok={'false' if errors else 'true'}\n")
    if errors:
        fh.write("failure_reason<<EOF\n")
        fh.write("\n".join(errors))
        fh.write("\nEOF\n")
PY

          echo "SLO report stored at $report_output"

      - name: Upload staging soak SLO report
        if: ${{ steps.verify_slo.outputs.report_path != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: staging_soak_report.json
          path: ${{ steps.verify_slo.outputs.report_path }}

      - name: Create staging soak alert issue
        if: ${{ steps.evaluate.outputs.overall_ok != 'true' || steps.verify_slo.outputs.slo_ok != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          summary="${{ steps.evaluate.outputs.summary_path }}"
          snapshot_ok="${{ steps.evaluate.outputs.snapshot_ok }}"
          timetoke_ok="${{ steps.evaluate.outputs.timetoke_ok }}"
          admission_ok="${{ steps.evaluate.outputs.admission_ok }}"
          body=$(cat <<"EOF"
## Staging soak regression

- Snapshot health: ${snapshot_ok}
- Timetoke SLOs: ${timetoke_ok}
- Admission reconciliation: ${admission_ok}

Summary artifact: ${summary}
EOF
)
          printf "%s\n" "$body" > issue.md
          gh issue create --title "Staging soak regression ${{ github.run_id }}" --body-file issue.md --label staging-soak

      - name: Fail on staging soak regression
        if: ${{ steps.evaluate.outputs.overall_ok != 'true' || steps.verify_slo.outputs.slo_ok != 'true' }}
        run: |
          set -euo pipefail
          reason="${{ steps.verify_slo.outputs.failure_reason }}"
          if [[ -n "$reason" ]]; then
            printf '%s\n' "$reason" >&2
          else
            echo "Staging soak checks failed" >&2
          fi
          exit 1

  phase3-evidence:
    name: Phase 3 evidence bundle
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Collect compliance evidence
        run: |
          set -euo pipefail
          cargo xtask collect-phase3-evidence

      - name: Prepare evidence metadata
        id: phase3
        run: |
          set -euo pipefail
          base_dir="target/compliance/phase3"
          if [ ! -d "$base_dir" ]; then
            echo "::error::No evidence bundles generated" >&2
            exit 1
          fi
          latest_dir=$(ls -1 "$base_dir" | grep -E '^[0-9]{8}T[0-9]{6}Z$' | sort | tail -n 1)
          if [ -z "$latest_dir" ]; then
            echo "::error::No timestamped evidence directories found" >&2
            exit 1
          fi
          manifest_path="$base_dir/$latest_dir/manifest.json"
          bundle_path="$base_dir/phase3-evidence-$latest_dir.tar.gz"
          if [ ! -f "$manifest_path" ]; then
            echo "::error::Evidence manifest $manifest_path is missing" >&2
            exit 1
          fi
          if [ ! -f "$bundle_path" ]; then
            echo "::error::Evidence bundle $bundle_path is missing" >&2
            exit 1
          fi
          echo "timestamp=$latest_dir" >>"$GITHUB_OUTPUT"
          echo "manifest=$manifest_path" >>"$GITHUB_OUTPUT"
          echo "bundle=$bundle_path" >>"$GITHUB_OUTPUT"

      - name: Upload Phase 3 evidence bundle
        uses: actions/upload-artifact@v4
        with:
          name: phase3-evidence-${{ steps.phase3.outputs.timestamp }}
          path: |
            ${{ steps.phase3.outputs.manifest }}
            ${{ steps.phase3.outputs.bundle }}

  plonky3-hash-audit:
    name: Plonky3 release hash audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Determine latest release tag
        id: release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag=$(gh release view --json tagName --jq '.tagName')
          if [[ -z "$tag" ]]; then
            echo "::error::Unable to determine latest release tag" >&2
            exit 1
          fi
          echo "tag=$tag" >>"$GITHUB_OUTPUT"
      - name: Download release manifests
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p dist/release
          gh release download "${{ steps.release.outputs.tag }}" \
            --pattern 'plonky3-setup-hashes.json*' \
            --pattern 'SHA256SUMS.txt*' \
            --dir dist/release
      - uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.4.0'
      - name: Verify checksum manifest signature
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          cosign verify-blob \
            --certificate dist/release/SHA256SUMS.txt.pem \
            --signature dist/release/SHA256SUMS.txt.sig \
            dist/release/SHA256SUMS.txt
      - name: Verify Plonky3 hash manifest signature
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          cosign verify-blob \
            --certificate dist/release/plonky3-setup-hashes.json.pem \
            --signature dist/release/plonky3-setup-hashes.json.sig \
            dist/release/plonky3-setup-hashes.json
      - name: Compute repository hash manifest
        run: |
          set -euo pipefail
          python3 scripts/generate_plonky3_artifacts.py \
            config/plonky3/setup \
            --verify \
            --hash-output dist/local-plonky3-setup-hashes.json
      - name: Compare repository and release manifests
        run: |
          set -euo pipefail
          if ! cmp -s dist/local-plonky3-setup-hashes.json dist/release/plonky3-setup-hashes.json; then
            echo "::error::Repository and release Plonky3 hash manifests differ" >&2
            diff -u dist/release/plonky3-setup-hashes.json dist/local-plonky3-setup-hashes.json || true
            exit 1
          fi
      - name: Validate checksum entry for hash manifest
        run: |
          set -euo pipefail
          release_sha=$(grep ' dist/plonky3-setup-hashes.json$' dist/release/SHA256SUMS.txt | awk '{print $1}')
          if [[ -z "$release_sha" ]]; then
            echo "::error::SHA256SUMS.txt does not contain dist/plonky3-setup-hashes.json" >&2
            exit 1
          fi
          local_sha=$(sha256sum dist/local-plonky3-setup-hashes.json | awk '{print $1}')
          if [[ "$release_sha" != "$local_sha" ]]; then
            echo "::error::Checksum mismatch for dist/plonky3-setup-hashes.json" >&2
            echo "release: $release_sha" >&2
            echo "local:   $local_sha" >&2
            exit 1
          fi
  validation:
    name: Nightly validation (${{ matrix.name }})
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: default
            features: ""
            no_default_features: ""
            experimental: false
          - name: prod-stwo
            features: "prod,prover-stwo"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-rpp-stark
            features: "prod,prover-stwo,backend-rpp-stark"
            no_default_features: "1"
            experimental: false
          - name: prod-stwo-plonky3
            features: "prod,prover-stwo,backend-plonky3"
            no_default_features: "1"
            experimental: true
          - name: wallet-hsm
            features: "wallet_hw"
            no_default_features: ""
            experimental: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Execute xtask test-all
        run: |
          set -euo pipefail
          if [ -n "${{ matrix.no_default_features }}" ]; then
            export XTASK_NO_DEFAULT_FEATURES="${{ matrix.no_default_features }}"
          fi
          if [ -n "${{ matrix.features }}" ]; then
            export XTASK_FEATURES='${{ matrix.features }}'
          fi
          cargo xtask test-all

  plonky3-gpu:
    name: Plonky3 GPU smoke
    runs-on: ubuntu-latest
    env:
      RUSTFLAGS: "-C debuginfo=0"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Build GPU backend
        run: |
          set -euo pipefail
          cargo build -p plonky3-backend --no-default-features --features plonky3-gpu

      - name: GPU backend smoke test
        run: |
          set -euo pipefail
          cargo test -p plonky3-backend --no-default-features --features plonky3-gpu -- consensus_proof_metadata_tracks_commitment_digest

  simnet:
    name: Simnet harness (prod, prover-stwo, plonky3)
    runs-on: ubuntu-latest
    env:
      XTASK_NO_DEFAULT_FEATURES: "1"
      XTASK_FEATURES: "prod,prover-stwo,backend-plonky3"
      RUSTFLAGS: "-C debuginfo=0"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Execute simnet harness
        run: |
          set -euo pipefail
          cargo xtask test-simnet

      - name: Analyze summaries
        run: |
          set -euo pipefail
          python3 scripts/analyze_simnet.py \
            target/simnet/ci-block-pipeline/summaries/ci-block-pipeline.json \
            target/simnet/ci-state-sync-guard/summaries/ci-state-sync-guard.json \
            target/simnet/consensus-quorum-stress/summaries/consensus_quorum_stress.json \
            target/simnet/snapshot-partition/summaries/snapshot_partition.json

      - name: Package artifacts
        run: |
          tar -czf simnet-artifacts.tar.gz -C target simnet

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: simnet-nightly
          path: simnet-artifacts.tar.gz

  simnet-rpp-stark:
    name: Simnet harness (prod, prover-stwo, rpp-stark)
    runs-on: ubuntu-latest
    env:
      XTASK_NO_DEFAULT_FEATURES: "1"
      XTASK_FEATURES: "prod,prover-stwo,backend-rpp-stark"
      RUSTFLAGS: "-C debuginfo=0"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Execute simnet harness
        run: |
          set -euo pipefail
          cargo xtask test-simnet

      - name: Package artifacts
        run: |
          tar -czf simnet-rpp-stark-artifacts.tar.gz -C target simnet

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: simnet-rpp-stark-nightly
          path: simnet-rpp-stark-artifacts.tar.gz

  simnet-regression:
    name: Simnet regression (prod, plonky3)
    runs-on: ubuntu-latest
    env:
      RUSTFLAGS: "-C debuginfo=0"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Execute regression sweep
        run: |
          set -euo pipefail
          rm -rf target/simnet/regression-nightly
          cargo run -p simnet --bin regression -- \
            --artifacts-root target/simnet/regression-nightly
      - name: Package regression artifacts
        run: |
          tar -czf simnet-regression.tar.gz -C target/simnet regression-nightly
      - name: Upload regression archive
        uses: actions/upload-artifact@v4
        with:
          name: simnet-regression-nightly
          path: simnet-regression.tar.gz

  snapshot-partition:
    name: Snapshot partition recovery audit
    runs-on: ubuntu-latest
    env:
      RUSTFLAGS: "-C debuginfo=0"
      SNAPSHOT_PARTITION_MAX_RESUME_MINUTES: "2"
      SNAPSHOT_PARTITION_MAX_CHUNK_RETRIES: "25"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Execute snapshot partition scenario
        run: |
          set -euo pipefail
          rm -rf target/simnet/snapshot-partition-nightly
          cargo run --locked --package simnet -- \
            --scenario tools/simnet/scenarios/snapshot_partition.ron \
            --artifacts-dir target/simnet/snapshot-partition-nightly

      - name: Generate snapshot partition report
        env:
          OBSERVABILITY_METRICS_OTLP_ENDPOINT: ${{ secrets.OBSERVABILITY_METRICS_OTLP_ENDPOINT }}
          OBSERVABILITY_METRICS_AUTH_TOKEN: ${{ secrets.OBSERVABILITY_METRICS_AUTH_TOKEN }}
          OBSERVABILITY_METRICS_HEADERS: ${{ secrets.OBSERVABILITY_METRICS_HEADERS }}
          OBSERVABILITY_METRICS_PROM_PATH: target/metrics/snapshot_partition.prom
          OBSERVABILITY_METRICS_SERVICE_NAME: compliance-nightly
          OBSERVABILITY_METRICS_SERVICE_INSTANCE: nightly-${{ github.run_id }}
          OBSERVABILITY_METRICS_SCOPE: nightly.snapshot_chaos
          OBSERVABILITY_METRICS_JOB: snapshot-chaos
        run: |
          set -euo pipefail
          python3 scripts/snapshot_partition_report.py \
            --summary target/simnet/snapshot-partition-nightly/summaries/snapshot_partition.json \
            --output snapshot_partition_report.json \
            --max-resume-minutes "${SNAPSHOT_PARTITION_MAX_RESUME_MINUTES}" \
            --max-chunk-retries "${SNAPSHOT_PARTITION_MAX_CHUNK_RETRIES}"

      - name: Upload snapshot partition report
        uses: actions/upload-artifact@v4
        with:
          name: snapshot_partition_report.json
          path: snapshot_partition_report.json

  simnet-compound-partitioned-backpressure:
    name: Simnet compound backpressure (optional)
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      RUSTFLAGS: "-C debuginfo=0"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Execute compound partitioned backpressure scenario
        run: |
          set -euo pipefail
          rm -rf target/simnet/compound-partitioned-backpressure
          cargo run --locked --package simnet -- \
            --scenario tools/simnet/scenarios/compound_partitioned_backpressure.ron \
            --artifacts-dir target/simnet/compound-partitioned-backpressure

      - name: Analyze compound backpressure summary
        run: |
          set -euo pipefail
          python3 scripts/analyze_simnet.py \
            target/simnet/compound-partitioned-backpressure/summaries/compound_partitioned_backpressure.json

      - name: Package compound backpressure artifacts
        run: |
          tar -czf simnet-compound-partitioned-backpressure.tar.gz -C target/simnet compound-partitioned-backpressure

      - name: Upload compound backpressure results
        uses: actions/upload-artifact@v4
        with:
          name: simnet-compound-partitioned-backpressure
          path: simnet-compound-partitioned-backpressure.tar.gz

  nightly-status:
    name: Publish nightly CI status snapshot
    needs:
      - verify-smoke-artifacts
      - worm-export
      - snapshot-partition
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TARGET_BRANCH: ${{ github.ref_name }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
      REPOSITORY: ${{ github.repository }}
      STATUS_BRANCH: status/nightly
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Download WORM retention report
        uses: actions/download-artifact@v4
        with:
          name: worm-retention-report.json
          path: phasec-artifacts/worm
          if-no-files-found: warn
      - name: Download snapshot partition report
        uses: actions/download-artifact@v4
        with:
          name: snapshot_partition_report.json
          path: phasec-artifacts/chaos
          if-no-files-found: warn
      - name: Validate collected Phase‑C artifacts
        run: |
          set -euo pipefail

          missing=()
          for artifact in \
            phasec-artifacts/worm/worm-retention-report.json \
            phasec-artifacts/chaos/snapshot_partition_report.json; do
            if [[ ! -f "$artifact" ]]; then
              missing+=("$artifact")
            fi
          done

          if [[ ${#missing[@]} -gt 0 ]]; then
            printf '::error::Fehlende Phase‑C-Artefakte: %s\n' "${missing[*]}" >&2
            exit 1
          fi
      - name: Generate nightly status summary
        run: |
          set -euo pipefail
          python3 scripts/update_nightly_status.py \
            --retention-report phasec-artifacts/worm/worm-retention-report.json \
            --chaos-report phasec-artifacts/chaos/snapshot_partition_report.json \
            --phasec-status-file phaseC_status.md
      - name: Ensure phaseC_status.md was updated
        run: |
          set -euo pipefail
          if git diff --quiet -- phaseC_status.md; then
            echo "::error::phaseC_status.md wurde nicht aktualisiert – fehlen WORM-/Chaos-Outputs?" >&2
            exit 1
          fi
      - name: Stage nightly status changes
        run: |
          set -euo pipefail
          git status --short
          if git diff --quiet -- docs/status/weekly.md nightly_status.md phaseC_status.md; then
            echo "Keine Änderungen an nightly_status.md, phaseC_status.md oder docs/status/weekly.md"
            exit 0
          fi
          git checkout "${DEFAULT_BRANCH:-main}"
          git pull --ff-only
          git checkout -B "$STATUS_BRANCH"
          git add nightly_status.md phaseC_status.md docs/status/weekly.md
      - name: Commit and push status snapshot
        if: ${{ !cancelled() }}
        run: |
          set -euo pipefail
          if git diff --cached --quiet; then
            echo "Keine Statusänderungen zum Commit vorhanden"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit -m "chore: refresh nightly status summary"
          git push origin "${STATUS_BRANCH}"
